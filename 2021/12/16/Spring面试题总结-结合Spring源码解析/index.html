<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring面试题总结-结合Spring源码解析 | 努力努力再努力xLg</title><meta name="keywords" content="Spring,面试"><meta name="author" content="努力努力再努力xLg,954253184@qq.com"><meta name="copyright" content="努力努力再努力xLg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] IOC的加载过程BeanFactory 与 FactoryBean 的区别？​    BeanFactory 在Spring 中就是一个Bean工厂的顶层接口类似于Java中的Objet类  ​    FactoryBean 则是Spring 中的一个非常重要的扩展点。他的功能也是非常神奇，可以完美的实现你狸猫换太子的把戏。 ​    在一个普通的Bean实现了FactoryBean接">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring面试题总结-结合Spring源码解析">
<meta property="og:url" content="https://assumejson.github.io/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="努力努力再努力xLg">
<meta property="og:description" content="[TOC] IOC的加载过程BeanFactory 与 FactoryBean 的区别？​    BeanFactory 在Spring 中就是一个Bean工厂的顶层接口类似于Java中的Objet类  ​    FactoryBean 则是Spring 中的一个非常重要的扩展点。他的功能也是非常神奇，可以完美的实现你狸猫换太子的把戏。 ​    在一个普通的Bean实现了FactoryBean接">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png">
<meta property="article:published_time" content="2021-12-16T04:41:35.000Z">
<meta property="article:modified_time" content="2021-12-16T04:44:02.928Z">
<meta property="article:author" content="努力努力再努力xLg">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://assumejson.github.io/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1db2391382f6b742f88f4d4bacf084e1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-DDLT48PGF4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DDLT48PGF4');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"9U77PNXQGB","apiKey":"c7a45d15e80ae02575c385328d379977","indexName":"dev_blog_search","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 努力努力再努力xLg","link":"链接: ","source":"来源: 努力努力再努力xLg","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring面试题总结-结合Spring源码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-16 12:44:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710212139.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">努力努力再努力xLg</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring面试题总结-结合Spring源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-16T04:41:35.000Z" title="发表于 2021-12-16 12:41:35">2021-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-16T04:44:02.928Z" title="更新于 2021-12-16 12:44:02">2021-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/">Develop</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>85分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring面试题总结-结合Spring源码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h2 id="IOC的加载过程"><a href="#IOC的加载过程" class="headerlink" title="IOC的加载过程"></a>IOC的加载过程</h2><h3 id="BeanFactory-与-FactoryBean-的区别？"><a href="#BeanFactory-与-FactoryBean-的区别？" class="headerlink" title="BeanFactory 与 FactoryBean 的区别？"></a>BeanFactory 与 FactoryBean 的区别？</h3><p>​    BeanFactory 在Spring 中就是一个Bean工厂的顶层接口类似于Java中的Objet类 </p>
<p>​    FactoryBean 则是Spring 中的一个非常重要的扩展点。他的功能也是非常神奇，可以完美的实现你狸猫换太子的把戏。</p>
<p>​    在一个普通的Bean实现了FactoryBean接口的话，在IoC加载的过程中，会判断Bean 是否实现了该接口，如果实现了，获取该实例会调用其实现的getObject类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBeanDemo</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 这里就是狸猫换太子的地方，可以自定义返回想要的实体类，并且注册到Spring容器中</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> Car.class;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 加载spring上下文</span></span><br><span class="line">		AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试 FactoryBean</span></span><br><span class="line">		Car factoryBeanDemo = (Car) context.getBean(<span class="string">&quot;factoryBeanDemo&quot;</span>);</span><br><span class="line">		System.out.println(factoryBeanDemo);</span><br><span class="line">		<span class="comment">// 获取真实的该类的bean对象</span></span><br><span class="line">		FactoryBeanDemo factoryBeanDemo1 = (FactoryBeanDemo) context.getBean(<span class="string">&quot;&amp;factoryBeanDemo&quot;</span>);</span><br><span class="line">		System.out.println(factoryBeanDemo1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Car car = (Car) context.getBean(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">		System.out.println(car.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">输出的结果：</span><br><span class="line">    car加载....</span><br><span class="line">    tank加载</span><br><span class="line">    car加载....</span><br><span class="line">    com.tuling.iocbeanlifecicle.Car@13c78c0b</span><br><span class="line">    com.tuling.iocbeanlifecicle.FactoryBeanDemo@12843fce</span><br><span class="line">    <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>​    可以看出Spring中的Bean如果要实现将原本不能很好符合Spring 生态的类，可以创建一个符合Spring的类来实现该接口，再利用这种狸猫换太子的属性来将自己本身的不符合Spring生态的类，但是需要放入到Spring容器中的这些类，都可以这样来实现，大名鼎鼎的Mybatis 中的mapper就是通过这种方式实现的。还有feign客户端等等</p>
<p>上述逻辑都在这个方法中<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;			</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			<span class="comment">//是不是工厂bean</span></span><br><span class="line">			<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">				<span class="comment">// 是factoryBean会先生成实际的bean  &amp;beanName 是用来获取实际bean的</span></span><br><span class="line">				Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">					<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">					<span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">										((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">								getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//调用真正的getBean的流程</span></span><br><span class="line">					<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//非工厂Bean 就是普通的bean</span></span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>​    具体看一下FactoryBean 类型在getBean时，是如何判断类型，根据类型调用getObject方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 第一步</span></span><br><span class="line">		Car factoryBeanDemo = (Car) context.getBean(<span class="string">&quot;factoryBeanDemo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用 org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 首先尝试在Spring 工厂中获取单利Bean 对象</span></span><br><span class="line"><span class="comment">// 4. 尝试去缓存中获取对象</span></span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="comment">// 5. 判断获取到bean是否是特殊的bean 对象，如果是FactoryBean 对象，则需要调用getObject来返回实例</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 判断 如果名字是以&amp; 开头的，则返回简单的bean对象，如果该类不是FactoryBean类，则会抛出异常（这里就从代码层面解释了 FactoryBean 可以通过 &amp;开头的名字获取到真实的bean对象）</span></span><br><span class="line">		<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				<span class="keyword">return</span> beanInstance;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 7. 如果是普通bean 则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 8. 走到这一步，则一定是FactoryBean了，会尝试在缓存中取，（第一次是取不到的。），走getObject方法</span></span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line"><span class="comment">// 8.1 使用工厂模式 创建对象</span></span><br><span class="line">					object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">				<span class="comment">// 8.2 真正的调用工厂bean的getObject()方法</span></span><br><span class="line">				object = factory.getObject();</span><br><span class="line"><span class="comment">// 这里就是整个逻辑闭环了！</span></span><br></pre></td></tr></table></figure>



<h4 id="在什么场景下使用FactoryBean？"><a href="#在什么场景下使用FactoryBean？" class="headerlink" title="在什么场景下使用FactoryBean？"></a>在什么场景下使用FactoryBean？</h4><p>​    MyBatis 中的Mapper 类使用的@Mapper 注解，并不是Spring中的注解，那么就是通过这种方式将这些mapper类放入到Spring容器中的。</p>
<h4 id="FactoryBean-生成的自定义对象与使用-Bean生成的对象有什么区别？"><a href="#FactoryBean-生成的自定义对象与使用-Bean生成的对象有什么区别？" class="headerlink" title="FactoryBean 生成的自定义对象与使用@Bean生成的对象有什么区别？"></a>FactoryBean 生成的自定义对象与使用@Bean生成的对象有什么区别？</h4><p>​    区别就是，使用@Bean 的对象是经过了IoC的完整的生命周期的，功能可以实现的更加丰富！！！</p>
<p>但是生成的Bean 还是会需要遵循Spring的Bean的生命周期，所以通过FactoryBean创建的Bean 是会经过后置处理器的<code>postProcessAfterInitialization</code>。</p>
<h2 id="Bean-在创建的过程中可以强行终止嘛？"><a href="#Bean-在创建的过程中可以强行终止嘛？" class="headerlink" title="Bean 在创建的过程中可以强行终止嘛？"></a>Bean 在创建的过程中可以强行终止嘛？</h2><p>​    Spring 中Bean的创建都是可以被终止的，可以通过Spring的热插拔机制，实现后置处理器来实现的。</p>
<p>​    在Spring IoC创建Bean时，执行Bean的后置处理器时，其中有一个后置处理器就可以实现对bean自动创建做终止，可以自己实现这个Bean的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Bean 的doCreate中的具体实现</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</span></span><br><span class="line"><span class="comment">// 该方法会 检查Bean 是否完全解析正确，然后调用第一个后置处理器</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 第1个bean后置处理器</span></span><br><span class="line"><span class="comment">			 * 通过bean的后置处理器来进行后置处理生成代理对象,一般情况下在此处不会生成代理对象</span></span><br><span class="line"><span class="comment">			 * 为什么不能生成代理对象,不管是我们的jdk代理还是cglib代理都不会在此处进行代理，因为我们的</span></span><br><span class="line"><span class="comment">			 * 真实的对象没有生成,所以在这里不会生成代理对象，那么在这一步是我们aop和事务的关键，因为在这里</span></span><br><span class="line"><span class="comment">			 * 解析我们的aop切面信息进行缓存</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 解析bean 是否实现了后置处理器</span></span><br><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="comment">//判断后置处理器是不是InstantiationAwareBeanPostProcessor</span></span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				<span class="comment">//把我们的BeanPostProcessor强制转为InstantiationAwareBeanPostProcessor</span></span><br><span class="line">				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 【很重要】</span></span><br><span class="line"><span class="comment">				 * 我们AOP <span class="doctag">@EnableAspectJAutoProxy</span> 为我们容器中导入了 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment">				 * 我们事务注解<span class="doctag">@EnableTransactionManagement</span> 为我们的容器导入了 InfrastructureAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="comment">				 * 都是实现了我们的 BeanPostProcessor接口,InstantiationAwareBeanPostProcessor,</span></span><br><span class="line"><span class="comment">				 * 进行后置处理解析切面</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">				<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109202150530.png" alt="image-20210920215033700"></p>
<p>Spring 中 所有的后置处理器 都统一的实现了BeanPostProcessor</p>
<blockquote>
<p>所以答案是</p>
<p>​    在Spring IoC 创建bena的生命周期中，是可以终止Bean的创建的。就是如果该bean 实现了<code>InstantiationAwareBeanPostProcessor</code></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109202153167.png" alt="image-20210920215306992"></p>
</blockquote>
<h3 id="具体怎么操作的呢？"><a href="#具体怎么操作的呢？" class="headerlink" title="具体怎么操作的呢？"></a>具体怎么操作的呢？</h3><p>​    就是实现InstantiationAwareBeanPostProcessor。就可以自己随心所欲的创建对象放到容器中了。</p>
<h2 id="ApplicationContext-与-BeanFactory的区别？"><a href="#ApplicationContext-与-BeanFactory的区别？" class="headerlink" title="ApplicationContext 与 BeanFactory的区别？"></a>ApplicationContext 与 BeanFactory的区别？</h2><ol>
<li>ApplicationContext 是BeanFactory的增强，引进了非常多的新特性，比喻支持国际化，支持资源访问、事件传递等等。</li>
<li>BeanFactory 加载Bean 是一种懒加载的方式，当第一次调用getBean时，才会去创建Bean，而ApplicationContext是在容器启动时，就会全量加载符合要求的Bean。这样带来的好处就是在程序启动时就可以检测出一些Bean定义的错误。缺点是占用内存较大</li>
<li>BeanFactory的设计理念大多的为了满足Spring整体框架而定义的，它是面向Spring框架的，而ApplicationContext则是面对开发者的。</li>
<li>BeanFactory和ApplicationContext都是支持postProcessor和beanFactoryprocessor的，但是BeanFactory需要自己手动注册，而ApplicationContext则是可以通过注解的方式。</li>
</ol>
<h2 id="如何往Spring容器中设置环境变量？"><a href="#如何往Spring容器中设置环境变量？" class="headerlink" title="如何往Spring容器中设置环境变量？"></a>如何往Spring容器中设置环境变量？</h2><p>​    重写<code>org.springframework.context.support.AbstractApplicationContext#initPropertySources</code>。可以实现。</p>
<h2 id="Spring怎么在Bean-创建之前给自定义的赋值"><a href="#Spring怎么在Bean-创建之前给自定义的赋值" class="headerlink" title="Spring怎么在Bean 创建之前给自定义的赋值"></a>Spring怎么在Bean 创建之前给自定义的赋值</h2><blockquote>
<p>Spring 怎么在Bean创建之前给其赋值</p>
<p>比喻说 给这个Bean 赋一些需要查询数据库的数据。在Spring的生命周期中可以怎么实现？</p>
</blockquote>
<p>可以分为三个步骤？</p>
<ol>
<li><p>初始化前</p>
<p>初始化前 可以使用@PostConstructor注解</p>
<blockquote>
<p>其实实现原理非常的简单。就是在Bean 的初始化前，使用反射尝试获取到该Bean 中的所有方法，然后再判断该Bean中是否有方法使用了该注解</p>
</blockquote>
</li>
<li><p>初始化中</p>
<p>类实现<code>InitializingBean</code>，Spring会在底层创建Bean 时，判断该Bean 是否instanof<code>InitializingBean</code>，然后再讲该Bean强转成<code>InitializingBean</code>类型调用<code>afterPropertiesSet</code>方法，也可以实现在Bean创建完成之前手动的设置一些需要的属性</p>
</li>
<li><p>初始化后</p>
<p>在初始化后，Bean已经创建成功了，这个时候再往里面填充属性就已经晚了。所以这个使用可以使用AOP动态代理的方式，进行属性织入，但是动态代理返回的Bean对象就是一个新的对象了。就是代理对象了。</p>
</li>
</ol>
<h2 id="Spring-bean的生命周期"><a href="#Spring-bean的生命周期" class="headerlink" title="Spring bean的生命周期"></a>Spring bean的生命周期</h2><p>Spring Bean 的生命周期大致大致可以分为两种。</p>
<ol>
<li>Bean的创建生命周期</li>
<li>Bean的销毁生命周期</li>
</ol>
<h3 id="Bean的创建生命周期简单介绍"><a href="#Bean的创建生命周期简单介绍" class="headerlink" title="Bean的创建生命周期简单介绍"></a>Bean的创建生命周期简单介绍</h3><p>一个userService.class对象 —–&gt; 解析无参构造方法（这里设计到了Spring中的一个推断构造的逻辑（如果一个对象中存在多个构造的各种情况））—&gt;普通对象（此时对象已经分配好了地址，这叫对象的实例化 但是此时对象是没有任何属性的，只有一个地址） —&gt; 依赖注入（属性赋值） —–&gt; 创建前（可通过@POSTConstructor注解进行回调） —-&gt; 创建中（初始化中 可以通过实现InitializingBean接口进行属性填充 ）—-&gt;创建后（可以使用AOP技术实现动态增强，但是需要注意的是，创建后这一步，Bean 是已经创建好的，所以此时使用AOP动态增强的Bean是一个新的Bean对象 代理对象<font color='red'>在代理对象中，在整个生命周期中，代理对象中的对象会持有一个容器中的一个普通对象，</font>）—-&gt;Bean</p>
<blockquote>
<p>上面是Bean的创建生命周期一个非常简单的顺序（在创建的时候会有大量的后置处理器也是Bean的生命周期中非常重要的一环）</p>
</blockquote>
<h2 id="如果Bean中存在多个构造，Spring该如何处理"><a href="#如果Bean中存在多个构造，Spring该如何处理" class="headerlink" title="如果Bean中存在多个构造，Spring该如何处理"></a>如果Bean中存在多个构造，Spring该如何处理</h2><p>​    这里分很多种情况</p>
<ol>
<li><p>Bean 存在无参构造</p>
<blockquote>
<p>Spring发现Bean存在有多个构造方法存在时，第一时间会寻找无参构造，如果存在无参构造，则Spring 会直接使用无参构造</p>
</blockquote>
</li>
<li><p>Bean 不存在无参构造，但是只有一个有参构造时</p>
<blockquote>
<p>这个时候，Spring会直接使用该有参构造</p>
</blockquote>
</li>
<li><p>Bean 不存在无参构造，但是有多个有参构造时</p>
<blockquote>
<p>这时Spring会不知道用哪一个，直接报错</p>
</blockquote>
</li>
</ol>
<h2 id="如果一个对象有多个-Bean注解，但是方法名不一样，Spring会如何寻找Bean对象"><a href="#如果一个对象有多个-Bean注解，但是方法名不一样，Spring会如何寻找Bean对象" class="headerlink" title="如果一个对象有多个@Bean注解，但是方法名不一样，Spring会如何寻找Bean对象"></a>如果一个对象有多个@Bean注解，但是方法名不一样，Spring会如何寻找Bean对象</h2><p>​    首先需要明确的是，在容器中使用多个@Bean注解注释同一个对象时，肯定会生成多个不同的对象，那么Spring是如何寻找这些个Bean对象的呢？</p>
<p>​    在从容器中拿一个Bean对象时，Spring会根据Bean的类型类获取，如果容器中存在多个Bean对象，那么再匹配Bean的名称。如果两个都没有匹配到就会报错了。</p>
<h2 id="如果在创建Bean的时候，有参构造是一个对象怎么办？"><a href="#如果在创建Bean的时候，有参构造是一个对象怎么办？" class="headerlink" title="如果在创建Bean的时候，有参构造是一个对象怎么办？"></a>如果在创建Bean的时候，有参构造是一个对象怎么办？</h2><p>​    Spring是支持三种注入的，其中就有一种是构造器注入，如果此时的无参构造中是一个对象，Spring会直接在容器中寻找是否有该对象。</p>
<ol>
<li><p>如果该对象是一个Spring的Bean </p>
<blockquote>
<p>Spring首先会根据类型寻找该Bean，如果找不到，则创建，如果找得到多个，再会使用参数名称进行寻找，如果此时任然找不到匹配的对象，会报错</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109240018417.png" alt="image-20210924001846401"></p>
<p>这里涉及到了Spring中的推断构造的逻辑。</p>
</blockquote>
</li>
</ol>
<h2 id="如果一个Bean对象同时被-Bean和-Component修饰，会出现两个对象吗？"><a href="#如果一个Bean对象同时被-Bean和-Component修饰，会出现两个对象吗？" class="headerlink" title="如果一个Bean对象同时被@Bean和@Component修饰，会出现两个对象吗？"></a>如果一个Bean对象同时被@Bean和@Component修饰，会出现两个对象吗？</h2><p>​    不会，在解析@Bean注解的时候，Spring会将存在容器中的Bean覆盖掉！！！</p>
<p>当然在spring中是会有一个配置的，配置是否允许覆盖。</p>
<h2 id="AOP中生成的代理对象里面的属性对象有值吗？"><a href="#AOP中生成的代理对象里面的属性对象有值吗？" class="headerlink" title="AOP中生成的代理对象里面的属性对象有值吗？"></a>AOP中生成的代理对象里面的属性对象有值吗？</h2><p>​    AOP在Bean的创建生命周期中是在尾部的，并且生成好了代理对象之后，并没有再进行依赖注入这一步，所以代理对象是没有值的。</p>
<h2 id="Spring的代理对象中的属性为null，那么Spring是如何调用到该对象执行制定方法的呢？"><a href="#Spring的代理对象中的属性为null，那么Spring是如何调用到该对象执行制定方法的呢？" class="headerlink" title="Spring的代理对象中的属性为null，那么Spring是如何调用到该对象执行制定方法的呢？"></a>Spring的代理对象中的属性为null，那么Spring是如何调用到该对象执行制定方法的呢？</h2><p>​    在AOP中，生成的代理对象是在ioc生命周期的尾部，所以生成的代理对象中的spring Bean 是不会再次注入的。</p>
<p>​    那么Spring在调用代理的方法时又是如何调用该对象中的注入对象的呢？</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202110212236383.png" alt="image-20211021223547374"></p>
<p>​    <img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202110212237558.png" alt="image-20211021223718345"></p>
<blockquote>
<p>调用的时候可以看到对象是一个代理对象，其中的属性是不会重新注入的。</p>
<p>在看看调用具体方法时，具体运行的对象是什么？</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202110212239045.png" alt="image-20211021223923823"></p>
<p>在调用之前会执行切面。执行完之后会调用容器中的普通bean对象，这样就解决了AOP之后代理对象属性值为null 的问题。</p>
<p><font color='red'>这样一来就引入了另外一个问题，Spring的事务就是基于AOP实现的，那么事务传播就会出现不同对象的调用出现事务不能传播的问题</font></p>
</blockquote>
<h2 id="AOP下事务不能传播的原因"><a href="#AOP下事务不能传播的原因" class="headerlink" title="AOP下事务不能传播的原因"></a>AOP下事务不能传播的原因</h2><p>​    </p>
<h2 id="BeanDefinition的定义，与Bean的几种定义方式"><a href="#BeanDefinition的定义，与Bean的几种定义方式" class="headerlink" title="BeanDefinition的定义，与Bean的几种定义方式"></a>BeanDefinition的定义，与Bean的几种定义方式</h2><p>​    在Spring 中，每一个Bean的生成都是先将bean 生成一个BeanDefinition放到一个BeanDefinitionMap中，再由容器对单例的bean进行统一的创建。</p>
<p>​    并且bean的创建方式除了xml @Bean @component 等Spring注解以外，Spring内部的源码还使用了另外一种方式，利用BeanDefinition来创建bean。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202110232226397.png" alt="image-20211023222609003"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202110232227498.png" alt="image-20211023222638492"></p>
<blockquote>
<p>在Spring 的源码中大量的使用这种方式去定义Bean的</p>
</blockquote>
<p><font color='red'>Spring 进一步精简了上述的操作，定义了一个BeanDefinitionReader来读取一个普通的类，并且可以将该类创建为Bean</font>。<code>org.springframework.context.annotation.AnnotatedBeanDefinitionReader</code>。而且在Spring的源码中也可以看到第一步就会创建一个该读取器去注册Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotatedBeanDefinitionReader annotatedBeanDefinitionReader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(context);</span><br><span class="line">annotatedBeanDefinitionReader.register(Person.class);</span><br><span class="line"></span><br><span class="line">System.out.println(context.getBean(<span class="string">&quot;person&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该组件在Spring的源码中，第一步就会去注册该读取器。用于读取Bean，并且注册</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202110232240771.png" alt="image-20211023224009587"></p>
</blockquote>
<h2 id="Spring-中的类型转换的运用"><a href="#Spring-中的类型转换的运用" class="headerlink" title="Spring 中的类型转换的运用"></a>Spring 中的类型转换的运用</h2><p>​    现在有一个对象，但是没有加入任何注解，所以spring 是不知道怎么将一个字符串转换为某个类型的。但是Spring提供了这种将字符串强制装换为一个bean的方</p>
<ol>
<li>JDK提供的一种类型强制装换器CustomEditorConfigurer</li>
<li>Spring也提供了类型装置转换器的实现</li>
</ol>
<h1 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h1><h2 id="生成BeanDefinition"><a href="#生成BeanDefinition" class="headerlink" title="生成BeanDefinition"></a>生成BeanDefinition</h2><blockquote>
<p>首先明确一点，在Spring源码中大多数都是封装好了，Spring将所有的扫描路径封装成了Resource对象，而扫描的类的元信息封装成了AnnotationMetadata</p>
<p>MetadataReader表示类的元数据读取器，主要包含了一个AnnotationMetadata，功能有</p>
<ol>
<li>获取类的名字、</li>
<li>获取父类的名字</li>
<li>获取所实现的所有接口名</li>
<li>获取所有内部类的名字</li>
<li>判断是不是抽象类</li>
<li>判断是不是接口</li>
<li>判断是不是一个注解</li>
<li>获取拥有某个注解的方法集合</li>
<li>获取类上添加的所有注解信息</li>
<li>获取类上添加的所有注解类型集合</li>
</ol>
<p>值得注意的是，CachingMetadataReaderFactory解析这些类的元信息时，使用的<code>ASM</code>技术，并不是一次性将所有符合要求的类一口气全部生成出来（这样严重影响性能），并且，最终得到的ScannedGenericBeanDefinition对象，<strong>beanClass属性存储的是当前类的名字，而不是class对象</strong>。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象）</p>
<p>这一步得到的BeanDefinition还可以通过解析xml文件中的</bean>,也可以解析@Bean注解来得到对应的BeanDefinition</p>
</blockquote>
<h2 id="Spring-Bean-生成之前的扫描操作"><a href="#Spring-Bean-生成之前的扫描操作" class="headerlink" title="Spring Bean 生成之前的扫描操作"></a>Spring Bean 生成之前的扫描操作</h2><p>​    会做一些列的判断，判断该类是否为一个正常的类，（不可以是接口，不可以是抽象类。）但是有一个特殊的地方，假设一个抽象类上试用了component注解，其中一个方法调用了lookup注解（那么该注入是有效的。）这一段在扫描的整个流程中是有判断的。</p>
<h3 id="BeanDefinition在生成时，判断类的属性"><a href="#BeanDefinition在生成时，判断类的属性" class="headerlink" title="BeanDefinition在生成时，判断类的属性"></a>BeanDefinition在生成时，判断类的属性</h3><p>​    判断Bean是否通过excludeFilters 过滤或者cludeFilter导入的bean ，或者使用Condition条件注解（判断Bean是否满足这些条件）    </p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111050807492.png" alt="image-20211105080730258"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111050808917.png" alt="image-20211105080800625"></p>
<p>​    判断类是否为接口，是否为顶级类，嵌套类，静态内部类，抽象类等。</p>
<p>只有抽象类是最特别的，如果想要在抽象类中使用Spring的IoC功能，那么其中的方法必须配合@Lookup注解来实现。</p>
<p>​    Java 中，如果一个类包含嵌套类，挥着静态内部类，都会在生成class 字节码时，在路径下多出一个类来。</p>
<h3 id="BeanDefinition在生成时，ScannedGenericBeanDefinition的beanClass属性定为Object的妙用。"><a href="#BeanDefinition在生成时，ScannedGenericBeanDefinition的beanClass属性定为Object的妙用。" class="headerlink" title="BeanDefinition在生成时，ScannedGenericBeanDefinition的beanClass属性定为Object的妙用。"></a>BeanDefinition在生成时，ScannedGenericBeanDefinition的beanClass属性定为Object的妙用。</h3><p>​    在生成BeanDefinition阶段，该属性只会单纯的保存bean的全限定名。等到真正getBean时，才会去初始化，才会被设置为真正的类。</p>
<p>​    并且Spring 使用ASM技术实现了懒加载机制。</p>
<p>​    所以该属性被设置为Object的妙用。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111040833611.png" alt="image-20211104083318327"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111040835110.png" alt="image-20211104083542903"></p>
<h3 id="Spring设置BeanName的操作，如果Bean的名称是ABtest，那么该bean的名字默认会生成啥？"><a href="#Spring设置BeanName的操作，如果Bean的名称是ABtest，那么该bean的名字默认会生成啥？" class="headerlink" title="Spring设置BeanName的操作，如果Bean的名称是ABtest，那么该bean的名字默认会生成啥？"></a>Spring设置BeanName的操作，如果Bean的名称是ABtest，那么该bean的名字默认会生成啥？</h3><p>​    在Spring内部的BeanName生成中，Spring判断Bean在没有设置Name时，会调用java的API生成BeanName</p>
<p>​    如果BeanName开头不是有且仅有一个大写字母，那么BeanName就直接为Bean的类名</p>
<p>​    AbTest —&gt; abTest</p>
<p>​    ABtest —-&gt; ABtest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decapitalize</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name.length() &gt; <span class="number">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class="number">1</span>)) &amp;&amp;</span><br><span class="line">                    Character.isUpperCase(name.charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> chars[] = name.toCharArray();</span><br><span class="line">    chars[<span class="number">0</span>] = Character.toLowerCase(chars[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并BeanDefinition（非常重要，解决bean之间的父子关系，实现父亲属性的覆盖）"><a href="#合并BeanDefinition（非常重要，解决bean之间的父子关系，实现父亲属性的覆盖）" class="headerlink" title="合并BeanDefinition（非常重要，解决bean之间的父子关系，实现父亲属性的覆盖）"></a>合并BeanDefinition（非常重要，解决bean之间的父子关系，实现父亲属性的覆盖）</h2><p>​    这一步非常的重要，在Spring实例化Bean 之前。Spring会在<code>finishBeanFactoryInitialization(beanFactory)</code>对生成的所有BeanDefinition进行合并，因为有的BeanDefinition存在父子关系。</p>
<p>​    Spring在合并BeanDefinition时，如果Bean 存在父亲，则会将父亲所有的属性覆盖到子Bean中，并且最终生成RootBeanDefinition存在合并后的集合中<code>mergedBeanDefinitions</code>，实际后续所有的getBean的操作都是从该集合中获取的。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111082244356.png" alt="image-20211108224424411"></p>
<h3 id="Spring在Bean-合并之后，实际生成了多少Bean对象"><a href="#Spring在Bean-合并之后，实际生成了多少Bean对象" class="headerlink" title="Spring在Bean 合并之后，实际生成了多少Bean对象"></a>Spring在Bean 合并之后，实际生成了多少Bean对象</h3><p>​    实际在Spring合并RootBeanDefinition后，有两种情况</p>
<ol>
<li>如果Bean 没有父类，则Bean 只会生成两个对象，一个<code>BeanDefinition</code>在<code>BeanDefinitionMap</code>中，另一个就是拷贝该<code>BeanDefinition</code>生成的一个<code>RootBeanDefinition</code>存在<code>mergedBeanDefinitions</code>。</li>
<li>如果Bean存在父类，则算上父类的个数（因为有可能父亲还有父亲），最后会合并成一个<code>RootBeanDefinition</code>存在<code>mergedBeanDefinitions</code>。</li>
</ol>
<blockquote>
<p>但是最后Spring在IoC容器getBean时，操作的是<code>mergedBeanDefinitions</code>，最后合并完生成的bean池</p>
</blockquote>
<h3 id="判断BeanFactory-与FactoryBean的区别"><a href="#判断BeanFactory-与FactoryBean的区别" class="headerlink" title="判断BeanFactory 与FactoryBean的区别"></a>判断BeanFactory 与FactoryBean的区别</h3><p>​    在最后的RootBeanDefinition中获取到Bean 之后，就会判断该Bean是否实现了BeanFactory。这个接口也可以算作Spring提供的一个可插拔的接口，用于在Bean生命周期中生成了Bean的时候实现对Bean最终生成的结果进行偷梁换柱的效果。</p>
<p>​    此时在判断FactoryBean的时候，该Bean的单例对象已经生成好了。</p>
<p>​    如果此时该Bean同时实现了<code>SmartFactoryBean</code></p>
<h4 id="如果FactoryBean同时实现了SmartFactoryBean"><a href="#如果FactoryBean同时实现了SmartFactoryBean" class="headerlink" title="如果FactoryBean同时实现了SmartFactoryBean"></a>如果FactoryBean同时实现了SmartFactoryBean</h4><p>​    SmartFactoryBean接口可以实现提前实例化FactoryBean；</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111091201985.png" alt="image-20211109120152498"></p>
<p>​    在扫描FactoryBean时，判断为true则直接调用getBean。</p>
<h3 id="Spring在创建Bean-的时候，会考虑到Spring-是否会有父工厂"><a href="#Spring在创建Bean-的时候，会考虑到Spring-是否会有父工厂" class="headerlink" title="Spring在创建Bean 的时候，会考虑到Spring 是否会有父工厂"></a>Spring在创建Bean 的时候，会考虑到Spring 是否会有父工厂</h3><p>​    在getBean时，会判断当前工厂中是否存在该Bean，也还会判断当前工厂的父工厂是否包含该Bean。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111092058764.png" alt="image-20211109205830213"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111092054712.png" alt="image-20211109205452659"></p>
<p>这种情况Spring也是支持的。就想Bean的合并一样的道理，在获取Bean时，Spring 会判断 当前spring工厂是否会有父工厂。</p>
<h3 id="Spring-getBean是带-amp-与不带，Spring内部的处理逻辑？"><a href="#Spring-getBean是带-amp-与不带，Spring内部的处理逻辑？" class="headerlink" title="Spring getBean是带&amp;与不带，Spring内部的处理逻辑？"></a>Spring getBean是带&amp;与不带，Spring内部的处理逻辑？</h3><blockquote>
<p>这里以userService 为例。</p>
</blockquote>
<ol>
<li><p>如果Spring获得一个普通的Bean ，直接使用的<code>userService</code>，则在Spring内部会进行如下操作</p>
<ol>
<li><p>假设userService 是一个FactoryBean</p>
<ol>
<li>那么Spring会在单例池中获取该Bean，会进行判断</li>
</ol>
<ul>
<li><p>判断该Bean 是否是一个FactoryBean </p>
<ul>
<li><p>不是</p>
<blockquote>
<p>则直接返回单例池中获取到的Bean对象</p>
</blockquote>
</li>
<li><p>是</p>
<blockquote>
<p>判断该获取Bean 的名字是否是以&amp;开头</p>
<ul>
<li>是：直接返回当前在单例池中获取的Bean对象</li>
<li>不是：则调用FactoryBean中的getObject方法返回对象（并且将该对象存在放<code>private final Map&lt;String, Object&gt; factoryBeanObjectCache = new ConcurrentHashMap&lt;&gt;(16);</code>）</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果获取Bean 带了&amp;前缀</p>
<ol>
<li>Spring会去除前缀现在单例池中获取该Bean 进行判断，如果该Bean 不是FactoryBean 则直接报错</li>
<li>如果该Bean 是FactoryBean 则直接返回单例池中的对象</li>
</ol>
</li>
</ol>
<h3 id="FactoryBean-中会生成几个对象，生成对象的时机是什么时候？"><a href="#FactoryBean-中会生成几个对象，生成对象的时机是什么时候？" class="headerlink" title="FactoryBean 中会生成几个对象，生成对象的时机是什么时候？"></a>FactoryBean 中会生成几个对象，生成对象的时机是什么时候？</h3><p>​    Spring容器会在Bean的生命周期中，将所有的Bena 实例化出来，但是会挨个判断Bean 是否是FactoryBean，</p>
<p>​    如果是FactoryBean的情况下，则创建Bean，<img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111092137798.png" alt="image-20211109213708560"></p>
<p>首先尝试在单例池中获取对象</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111092139929.png" alt="image-20211109213902578"></p>
<blockquote>
<p>所以从这里可以看出来，在单例池中存放的该Bean 的对象，key依然是普通Bean的名字（并没有加上&amp;等前缀）</p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111092159398.png" alt="image-20211109215946137"></p>
<blockquote>
<p>在Spring源码中，在启动时，在本地合并的RootBeanDefinition中存在一个当前符合Component的Bean，在getBean时，如果该Bean是FactoryBean，则会将该Bean 再合并生成一个Bean，然后再调用该对象的getObject方法</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111092202093.png" alt="image-20211109220228861"></p>
<p>将生成的新的FactoryBean 对象存在<code>factoryBeanObjectCache</code>缓存中。再调用getObject方法</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111092203075.png" alt="image-20211109220328588"></p>
</blockquote>
</li>
</ol>
<p><strong>总结</strong></p>
<p>​    在Spring整个生命周期中，一个FactoryBean 首先生成自身的对象，并且在单例池中的key也还是自身的名字（但是如果需要获取该Bean 的原本实例，则需要在获取名字之前添加&amp;符号（支持多个）），并且生产一个BeanDefinition（原始对象）存在BeanDefinitionMap中。生成一个合并之后的RootBeanDefinition存放在<code>mergedBeanDefinitions</code>中，但是此时，FactoryBean 中的getObject并没有执行。</p>
<p>​    当调用getBean获取该对象时（没有带&amp;），则Spring会再创建一个<code>RootBeanDefinition</code>存放在mergedBeanDefinitions中。然后再调用getObject方法，返回的实例存在<code>factoryBeanObjectCache</code>缓存中。</p>
<p>​    此时就FactoryBean一个Bean 在Spring容器中，就有一个BeanDefinition，两个RootBeanDefinition，一个Bean对象存在单例池（本身，key为该类的BeanName），一个getObject返回的object对象存在<code>factoryBeanObjectCache</code>（key 为该类的beanName）。</p>
<hr>
<h1 id="以上就是实例化之前的操作。"><a href="#以上就是实例化之前的操作。" class="headerlink" title="以上就是实例化之前的操作。"></a>以上就是实例化之前的操作。</h1><h2 id="实例化之前的加载类的操作"><a href="#实例化之前的加载类的操作" class="headerlink" title="实例化之前的加载类的操作"></a>实例化之前的加载类的操作</h2><p>​    在所有符合规定的Bean 都把柄加载成为RootBeanDefinition之后，就是要依次将这些非懒加载的单例Bean创建出来。但是在创建之前必须先将这些类加载出来。</p>
<p>​    <code>Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</code>解析BeanFactory中的beanClass属性，会判断该属性是否是Class 属性，不是的话，就要根据当前beanClass 的string类型的全限定名进行加载操作。</p>
<h2 id="Bean的实例化之前（第一次调用Bean的后置处理器）"><a href="#Bean的实例化之前（第一次调用Bean的后置处理器）" class="headerlink" title="Bean的实例化之前（第一次调用Bean的后置处理器）"></a>Bean的实例化之前（第一次调用Bean的后置处理器）</h2><p>​    在解析玩BeanClass之后，Spring会判断该容器中是否存在实现了<code>InstantiationAwareBeanPostProcessor</code>，该扩展节点，允许用户在Bean实例化之前做一些初始化动作（AOP、事务都是以此为切入点的。），值得注意的一点就是，当类实现了该扩展点，如果判断某个Bean时，返回了一个实例对象，那么该Bean将不会参与Spring后面的生命周期操作，而是直接进入到Spring Bean的初始化后的后置处理器(跳过Spring Bean 的生命周期)。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111130801482.png" alt="image-20211113080105416"></p>
<p>​        这样做是为了实现Bean 的AOP切入，也类似于FactoryBean的getObject方法，当返回值不会空时，直接进入到Bean的初始化后的后置处理器。</p>
<blockquote>
<p>然后进入到Bean 的初始化阶段（此时的Bean 只是在JVM中生成了地址，并没有进行属性填充等操作，现在还是一个空壳子），Bean 还要经过 –&gt;属性填充（其中包括依赖注入等问题）–&gt;aware–&gt;初始化前–&gt;初始化–&gt;初始化后</p>
</blockquote>
<p>​    该回调方法在调用时候，会比较特殊，在调用时，不管有多少后置处理器，一旦有返回值，则直接return，因为Spring也不知道如果存在多个返回值的情况下，到底选择那个对象返回给用户。（因为在实例化前，用户完全可以自定义一个对象，终止Spring的创建过程。）</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111152212123.png" alt="image-20211115221231215"></p>
<h3 id="Spring-Bean-合并后的后置处理器"><a href="#Spring-Bean-合并后的后置处理器" class="headerlink" title="Spring Bean  合并后的后置处理器"></a>Spring Bean  合并后的后置处理器</h3><p>​    该扩展点，在Spring的内部用于对@Autowrite @Value 等注解进行预解析</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111152218712.png" alt="image-20211115221822368"></p>
<p><code>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</code>。</p>
<h2 id="实例化后，调用instanceBeanPostProcessor中的postProcessAfterInstantiation"><a href="#实例化后，调用instanceBeanPostProcessor中的postProcessAfterInstantiation" class="headerlink" title="实例化后，调用instanceBeanPostProcessor中的postProcessAfterInstantiation"></a>实例化后，调用instanceBeanPostProcessor中的postProcessAfterInstantiation</h2><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111160755170.png" alt="image-20211116075518575"></p>
<h3 id="为什么实例化前后传入的参数不同？"><a href="#为什么实例化前后传入的参数不同？" class="headerlink" title="为什么实例化前后传入的参数不同？"></a>为什么实例化前后传入的参数不同？</h3><p>​    原因就是，在实例化前，Bean还没有实例化，目前只有一个Class 对象，用户可以直接返回一个新的Bean对象，来跳过Spring Bean的生命周期。而在实例化后则是一个Bean，原因就是在该Bean已经在JVM中生成好了地址，用户可以手动的创建实例，并且自定义的设置属性，当返回false时，就不用Spring代替初始化了。</p>
<h2 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h2><h3 id="Spring的自我注入byType、byName"><a href="#Spring的自我注入byType、byName" class="headerlink" title="Spring的自我注入byType、byName"></a>Spring的自我注入byType、byName</h3><p>​    在Spring解析@Autowire等依赖注入时，Spring会解析自己知道的依赖注入，也就是常说又搞不清楚的byName、byType。Spring可以通过该方法进行依赖注入。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111160800918.png" alt="image-20211116080027367"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义为Bean</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SpringOwnerAutowireService <span class="title">springOwnerAutowireService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SpringOwnerAutowireService();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringOwnerAutowireService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printlnTestService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(testService);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类加入到Spring容器中</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时输入的结果为 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在testService 上加上Autowired注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringOwnerAutowireService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printlnTestService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(testService);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时的结果肯定就不是null了，但是这个依赖注入是通过BeanPostProcessor扩展点实现的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这种方式则是利用Spring的自带解析进行依赖注入。</span></span><br><span class="line">	<span class="meta">@Bean(autowire = Autowire.BY_NAME)</span> <span class="comment">// 这里byType 也可以</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SpringOwnerAutowireService <span class="title">springOwnerAutowireService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SpringOwnerAutowireService();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringOwnerAutowireService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printlnTestService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(testService);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestService</span><span class="params">(TestService testService)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.testService = testService;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 com.tuling.iocbeanlifecicle.lg.service.TestService@8b87145</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="byName、byType-的实现逻辑"><a href="#byName、byType-的实现逻辑" class="headerlink" title="byName、byType 的实现逻辑"></a>byName、byType 的实现逻辑</h3><p>​    两种实现的前提是，给成员变量设置了set方法。</p>
<ul>
<li><p>byType</p>
<ul>
<li>查询的是成员变量的属性。然后调用set方法。<ul>
<li>其实在Spring的底层实现中，Spring 是直接找setXXX方法，只要参数中的入参类型在Spring容器中能够找到，都会调到（所以这也是很坑的一个地方，并不能灵活的实现）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringOwnerAutowireService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	private TestService testService;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printlnTestService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		System.out.println(testService);</span></span><br><span class="line">		System.out.println(<span class="string">&quot;......byType Test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestService</span><span class="params">(TestService testService)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;set method is invoke&quot;</span>);</span><br><span class="line">		System.out.println(testService);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set method is invoke</span></span><br><span class="line"><span class="comment">// com.tuling.iocbeanlifecicle.lg.service.TestService@16f7c8c1</span></span><br><span class="line"><span class="comment">// ......byType Test</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111161131226.png" alt="image-20211116113134090"></p>
<blockquote>
<p>byType 底层的实现逻辑就是，在该类中寻找所有的set 方法，然后判断这些方法中的入参是否能够在spring中找到，如果能够找到那么就会进行依赖注入。</p>
</blockquote>
</li>
<li><p>byName</p>
<ul>
<li>byName可能会直接想到，Spring是直接调用的参数中的beanName在Spring 容器中寻找，其实底层并不是这样实现的，而是使用setXxx方法名，获得Xxx之后，在判断该Bean是否存在。如果存在则进行依赖注入</li>
</ul>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111161140878.png" alt="image-20211116114014365"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111161142181.png" alt="image-20211116114219146"></p>
<p>如果是setUserService123，该方法就不会呗执行</p>
</li>
</ul>
<h3 id="为什么Spring已经有了自己的依赖注入，还要加入注解方式呢"><a href="#为什么Spring已经有了自己的依赖注入，还要加入注解方式呢" class="headerlink" title="为什么Spring已经有了自己的依赖注入，还要加入注解方式呢?"></a>为什么Spring已经有了自己的依赖注入，还要加入注解方式呢?</h3><p>​    原因就是该方式的注入实在是太灵活了，在方法内只要是setXxx方法，只要符合规格，都会进行依赖注入。而注解方式就更加的可控，和多样性。</p>
<p>​    该方式在Spring 5.3 之后已经被过期。</p>
<h2 id="初始化前，属性赋值"><a href="#初始化前，属性赋值" class="headerlink" title="初始化前，属性赋值"></a>初始化前，属性赋值</h2><p>​    Spring 通过BeanPostProcessor的扩展接口的方式实现了对@Autowired @Resource @Value等注解，通过</p>
<p> InstantiationAwareBeanPostProcessor.postProcessPropertyValues 来解析的。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111161336777.png" alt="image-20211116133614432"></p>
<p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues</code>就是用来解析@Autowired 的</p>
<h2 id="Aware-的执行场景是什么？"><a href="#Aware-的执行场景是什么？" class="headerlink" title="Aware 的执行场景是什么？"></a>Aware 的执行场景是什么？</h2><p>​    Spring 将所有Aware 放在了初始化前。（与BeanFactory 的共同属性）</p>
<h2 id="ApplicationContext中增强的Aware属性在哪里加载？"><a href="#ApplicationContext中增强的Aware属性在哪里加载？" class="headerlink" title="ApplicationContext中增强的Aware属性在哪里加载？"></a>ApplicationContext中增强的Aware属性在哪里加载？</h2><p>​    在初始化前，所有的增强Aware 是通过BeanPostProcessor扩展点来实现的。在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization在这一步，ApplicationContextAwareProcessor会调用所有的Aware进行增强</span><br></pre></td></tr></table></figure>

<h2 id="PostConstructor和-PreDestroy注解在那里加载？"><a href="#PostConstructor和-PreDestroy注解在那里加载？" class="headerlink" title="@PostConstructor和@PreDestroy注解在那里加载？"></a>@PostConstructor和@PreDestroy注解在那里加载？</h2><p>​    也是在初始化前，也是通过BeanPostProcessor进行加载的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanPostProcessor.postProcessBeforeInitialization(Object bean, String beanName)调用初始化前的后置处理器。<span class="meta">@Postust</span> 等注解在这里解析这里只要有一个返回<span class="keyword">null</span>，则直接终止循环，返回原始的对象（这里会一直追溯到org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#CommonAnnotationBeanPostProcessor早在Spring创建工厂时，注册BeanPostProcessor就生成了该beanPostProcessor，对<span class="meta">@PostConstructor</span> <span class="meta">@PreDestroy</span> 注解）</span><br></pre></td></tr></table></figure>

<h2 id="初始化时会有那些操作"><a href="#初始化时会有那些操作" class="headerlink" title="初始化时会有那些操作"></a>初始化时会有那些操作</h2><p>​    初始化时，会判断是否有实现了InitializingBean，并且存在afterPropertiesSet方法。然后会回调该方法。</p>
<h2 id="初始化后"><a href="#初始化后" class="headerlink" title="初始化后"></a>初始化后</h2><p>​    初始化后，会调BeanPostProcessor的postProcessorAfterInitialization方法</p>
<p>该方法在Bean生命周期中是非常重要的。AOP和事务的代理对象都是在这个地方生成的。</p>
<h1 id="Bean-销毁"><a href="#Bean-销毁" class="headerlink" title="Bean 销毁"></a>Bean 销毁</h1><p>​    Spring是怎么对Bean进行销毁的呢？难道是在对象呗垃圾回收机制回收的时候调用销毁方法嘛？</p>
<p>​    spring 这个是做不到的。在Spring中Bean的销毁是针对Spring 容器的。当容器销毁时，实现了销毁方法的Bean会执行他们的销毁方法。</p>
<h2 id="Spring-容器销毁的流程-TODO"><a href="#Spring-容器销毁的流程-TODO" class="headerlink" title="Spring 容器销毁的流程 TODO"></a>Spring 容器销毁的流程 TODO</h2><p>​    </p>
<h1 id="Spring-Bean的生命周期总结-TODO"><a href="#Spring-Bean的生命周期总结-TODO" class="headerlink" title="Spring Bean的生命周期总结 TODO"></a>Spring Bean的生命周期总结 TODO</h1><h1 id="Spring依赖注入"><a href="#Spring依赖注入" class="headerlink" title="Spring依赖注入"></a>Spring依赖注入</h1><p>​    Spring 的依赖注入在Spring 的生命周期中是处在实例化后，初始化之前的操作。其中Spring会考虑到非常多的情况。</p>
<h2 id="Spring自带的依赖注入byName、byType"><a href="#Spring自带的依赖注入byName、byType" class="headerlink" title="Spring自带的依赖注入byName、byType"></a>Spring自带的依赖注入byName、byType</h2><p>​    在Spring 进行依赖注入的第一步，Spring就提供了一种基于byName、byType的方式进行依赖注入，这是一种Spring自带的依赖注入。</p>
<blockquote>
<p>只要在Spring的Bean中，将一个对象定义为Bean，那么有可能不给其内部的局部变量成员变量只需要提供set方法就可以实现属性的依赖注入。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241251284.png" alt="image-20211124125130102"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241251777.png" alt="image-20211124125157440"></p>
<p>在这种情况下，Spring也可以完成对该Bean 中的所有set方法进行依赖注入。</p>
<ul>
<li><p>上述方法是基于byName，byName底层是基于SetXxx之后的Xxx在容器中寻找是否存在该Bean，如果存在则会将入参进行依赖注入。</p>
<ul>
<li><p>所以如果方法名为setOrderService123，这个时候的set方法则不会被执行了。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241259324.png" alt="image-20211124125941817"></p>
</li>
</ul>
</li>
<li><p>byType，则是判断入参的类型是否在Spring 容器中存在，如果存在则进行依赖注入的。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241300881.png" alt="image-20211124130020438"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241303543.png" alt="image-20211124130302928"></p>
</li>
</ul>
</blockquote>
<p>看看Spring 底层的具体实现是咋样的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**		 * Spring 的 自我注入		 * 判断我们的bean的属性注入模型		 * AUTOWIRE_BY_NAME 根据名称注入 setXxx 方法中的Xxx 名字		 * AUTOWIRE_BY_TYPE 根据类型注入 setXxx 方法中的参数类型		 */</span>		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;			            <span class="comment">//把PropertyValues封装成为MutablePropertyValues			            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);			            //根据bean的属性名称注入			            if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;				autowireByName(beanName, mbd, bw, newPvs);			&#125;			            //根据bean的类型进行注入			            if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;				autowireByType(beanName, mbd, bw, newPvs);			&#125;			            //把处理过的 属性覆盖原来的			            pvs = newPvs;		&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="byName底层实现逻辑"><a href="#byName底层实现逻辑" class="headerlink" title="byName底层实现逻辑"></a>byName底层实现逻辑</h3><p><code>autowireByName(beanName, mbd, bw, newPvs)</code></p>
<p>​    在解析beanWarpper（bw）的时候，首先会获取当前bean中所有的PropertyDescriptor[] pds = bw.getPropertyDescriptors()该对象是java.beans包下的一个类。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241326828.png" alt="image-20211124132613396"></p>
<blockquote>
<p>当前Bena的包装类中的bean是还没有完成属性填充的。</p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241328849.png" alt="image-20211124132805481"></p>
<p>Spring获取当前bean中所有的set方法，（当前Bean只有三个set方法，为什么有四个参数呢？其中的name=class到底是个什么东西？）</p>
<h4 id="Spring-在获取Bean的set方法时，为什么会返回一个name-class-的属性呢？"><a href="#Spring-在获取Bean的set方法时，为什么会返回一个name-class-的属性呢？" class="headerlink" title="Spring 在获取Bean的set方法时，为什么会返回一个name = class 的属性呢？"></a>Spring 在获取Bean的set方法时，为什么会返回一个name = class 的属性呢？</h4><p>​    首先我们先来弄懂，PropertyDescriptor是个什么东西，该类是java.beans下提供的一个获取类的get、set方法的一个类。</p>
<p>​    那么为什么在spring中会返回一个name=class 的属性呢？</p>
<blockquote>
<p>原因就是所有的类中都会有一个getClass 的方法存在。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241357220.png" alt="image-20211124135742940"></p>
<p>所以这个返回的name=class的PropertyDescriptor对象中是只能读，不能写的。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241337074.png" alt="image-20211124133734705"></p>
<p>其他方法都是可读可写的：</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241338363.png" alt="image-20211124133815063"></p>
<p>我这里并没有按照规范提供get和set方法，所以这里只获取到了读的方法。</p>
</blockquote>
<hr>
<p>所以在Spring中的实现就是基于java的这种get set方法实现的。</p>
<p>Spring会筛选出所有的set方法。并且获取其setXxx中的xxx名字放到一个set集合中</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241422383.png" alt="image-20211124142159999"></p>
<blockquote>
<p>所以这一步是不会返回getClass方法的因为其没有set方法的。</p>
<p>说到过滤，Spring在这里也会进行过滤的。包括以下这些情况</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241429102.png" alt="image-20211124142958768"></p>
<p>但是以上这些情况@Aotuwerid注解是会进行解析的。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241433210.png" alt="image-20211124143315402"></p>
<p>这种情况Spring就会直接忽略掉，不会再自己的依赖注入找那个进行属性注入的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pvs.contains(pd.getName())  <span class="comment">// 这一步的判断可以对应在属性合并之后MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition的后置处理器中，可以对属性进行设置的情况下。如果用户自己设置了属性，这里也会进行忽略的。</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>循环刚才获取的 benaName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String propertyName : propertyNames) &#123;   <span class="comment">//判断该属性名称是不是引用对象       if (containsBean(propertyName)) &#123;              //显示的调用getBean所有属性的名称bean显示调用BeanFactory              Object bean = getBean(propertyName);              //把我们依赖的属性添加到pvs中,这里只是简单的添加到pvs属性中，并没有直接去赋值（@Autowired 注解则是直接赋值的）             pvs.add(propertyName, bean);              //注册当前bean和属性依赖bean的依赖关系              registerDependentBean(propertyName, beanName);             if (logger.isDebugEnabled()) &#123;         logger.debug(&quot;Added autowiring by name from bean name &#x27;&quot; + beanName +               &quot;&#x27; via property &#x27;&quot; + propertyName + &quot;&#x27; to bean named &#x27;&quot; + propertyName + &quot;&#x27;&quot;);      &#125;   &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里并没有直接将值赋值给Bean，而是添加到PVS属性中，并且将当前在容器中的对象与当前解析的对象进行依赖关联。</p>
</blockquote>
<h3 id="byType"><a href="#byType" class="headerlink" title="byType"></a>byType</h3><p>​    与byName大致类似，首先先找出所有的set方法，然后通过 pd.getPropertyType()获取到入参类型，然后根据类型容器中判断是否有该类型的bean存在，如果存在则能够顺利的依赖注入了。</p>
<p><strong>总结</strong></p>
<p>​    两者都是将所有的属性添加到pvs集合中，然后由后续的applyPropertyValues(beanName, mbd, bw, pvs);进行真正的属性赋值，</p>
<p>​    在执行赋值之前，还有一个扩展点的后置处理器，就是用来解析@Autowire @Resoure @Value 等属性依赖注解</p>
<h2 id="Autowire-注解依赖注入"><a href="#Autowire-注解依赖注入" class="headerlink" title="Autowire 注解依赖注入"></a>Autowire 注解依赖注入</h2><p>​    Spring 在提供了自己的依赖注入之后，还支持注解的方式，就是因为自己的依赖注入，太宽泛了，只要有set方法都可以进行依赖注入，并且是在一个类中进行的。注解的方式显然更加的合理，更加的方便，和可定制的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<span class="keyword">if</span> (hasInstAwareBpps) &#123;   <span class="comment">//获取所有的后置处理器   for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;      if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;         //对依赖对象进行后置处理，真正处理@Autowire @Resoure @Value 等属性依赖注解         pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);         if (pvs == null) &#123;            return;         &#125;      &#125;   &#125;&#125;// org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor#postProcessPropertyValues</span></span><br></pre></td></tr></table></figure>

<p>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues就是用来解析@Autowire注解的</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241537379.png" alt="image-20211124153706867"></p>
<ul>
<li><p>当前类还实现了MergedBeanDefinitionPostProcessor。</p>
<ul>
<li>所以在实例化后，属性填充前就会运行org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition。</li>
<li>所以该类早在执行org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues前，就已经将所有的使用了@Autowire注解的方法，成员变量，局部变量都已经全部遍历出来了。并且放到了缓存中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;   <span class="comment">// 寻找bean中所有被@Autowired注释的属性，并将属性封装成InjectedElement类型   InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);   metadata.checkConfigMembers(beanDefinition);&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>我们自己在编写自己的Spring时，第一步就是先找到所有的标注有该注解的成员变量。</p>
<p>在Spring中被称之为寻找注入点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;<span class="comment">// 从缓存中拿到注解元数据， 缓存没有载解析一遍InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);try &#123;// 注入metadata.inject(bean, beanName, pvs);&#125;catch (BeanCreationException ex) &#123;throw ex;&#125;catch (Throwable ex) &#123;throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex);&#125;return pvs;&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="寻找注入点"><a href="#寻找注入点" class="headerlink" title="寻找注入点"></a>寻找注入点</h3><ol>
<li><p>findAutowiringMetadata(beanName, bean.getClass(), pvs);遍历所有的扫描到的类寻找使用Autowire注解的类</p>
</li>
<li><p>metadata = buildAutowiringMetadata(clazz); // 将获取到的Autowire的属性，封装为InjectionMetadata类型</p>
</li>
<li><p>AnnotationAttributes ann = findAutowiredAnnotation(field);// 判断当前field属性是否含有@Autowired、@Value、@Inject的注解</p>
<ol>
<li>```java<br>public AutowiredAnnotationBeanPostProcessor() {   this.autowiredAnnotationTypes.add(Autowired.class);   this.autowiredAnnotationTypes.add(Value.class);   try {      this.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)            ClassUtils.forName(“javax.inject.Inject”, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));      logger.info(“JSR-330 ‘javax.inject.Inject’ annotation found and supported for autowiring”);   }   catch (ClassNotFoundException ex) {      // JSR-330 API not available - simply skip.   }}// 该类在初始化时，会往集合中添加这三个注解最外层的循环遍历中就会找出所有使用了这三个注解其中一个的的所有属性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 如果获取到的属性是用静态的static，则直接报错，spring是不支持给静态属性进行依赖注入的。</span><br><span class="line"></span><br><span class="line">5. 遍历完所有的变量之后，再来遍历所有的方法</span><br><span class="line"></span><br><span class="line">   1. Spring 中的@Autowire注解时支持直接给方法进行注解的。</span><br><span class="line">   2. 排除所有的桥接方法，找出真正的使用该注解的方法。</span><br><span class="line"></span><br><span class="line">### 桥接方法</span><br><span class="line"></span><br><span class="line">​	在java中，一个具有泛型的类，使用注解之后，字节码中会存在两个类。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface UserServiceInterface&lt;T&gt; &#123;   void setOrderService(T t);&#125;@Componentpublic class BridgeMethodTest implements UserServiceInterface&lt;OrderService&gt; &#123;	private OrderService orderService;	@Override	@Autowired	public void setOrderService(OrderService orderService) &#123;		this.orderService = orderService;	&#125;	public void test() &#123;		System.out.println(&quot;test123&quot;);	&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241555596.png" alt="image-20211124155554150"></p>
<blockquote>
<p>原始方法的字节码</p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241557788.png" alt="image-20211124155743987"></p>
<blockquote>
<p>其实所有的入参的父类都是object ，这就是包含了所有情况的泛型情况。</p>
</blockquote>
<p>Spring 如果直接使用java反射去获取method，再判断，那么Spring会直接获取到两个方法，Spring自己也不知道哪一个是用户的方法，所以这里Spring会将所有的桥接方法过滤掉的。</p>
<h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h4><p>​    org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues中，进行属性注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">metadata.inject(bean, beanName, pvs);</span><br></pre></td></tr></table></figure>

<p>在属性注入的时候，Spring会判断PVS属性集合中是否存在该注入的对象，如果存在则会直接skip。使用用户自定设置的对象。</p>
<p>假如用户在MergedBeanDefinitionPostProcessor中设置了属性（当然该属性的设置，一定要要求bean中有对应的set方法）</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241621034.png" alt="image-20211124162158457"></p>
<p>所以，在解析@Autowired注解的时候，会判断PVS如果存在该属性，则不会再创建，而是直接使用用户定义的。</p>
<ul>
<li><p>然后使用反射调用set方法进行依赖注入</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111241626655.png" alt="image-20211124162621265"></p>
</li>
</ul>
<blockquote>
<p>所以这一步就可以看到Spring会调用使用了@Autowire注解的方法的。</p>
</blockquote>
<h3 id="Autowire中的核心方法resolveDependency"><a href="#Autowire中的核心方法resolveDependency" class="headerlink" title="@Autowire中的核心方法resolveDependency"></a>@Autowire中的核心方法resolveDependency</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;      logger.debug(<span class="string">&quot;Processing injected element of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + element);   &#125;   <span class="comment">// 循环注入，这里有可能是AutowiredFieldElement也可能AutowiredMethodElement，因此调用的inject是2个不同的方法   // 这里是调用的InjectedElement 的两个实现，一个是针对字段的，一个是针对方法的。   element.inject(target, beanName, pvs);&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述中的注入方法，是针对两个实现的，一个是针对字段的，一个是针对方法的。</p>
<p>在分许这两种实现的前提下，首先要明确一点的就是：在Spring的使用过程中，使用@Autowire注解作用在字段上，一定只能描述一个字段。</p>
<p>但是当通在方法上时，方法就可以传入多个参数了，这个时候，Spring需要做的工作就非常多了。</p>
</blockquote>
<h4 id="resolveDependency-核心解析"><a href="#resolveDependency-核心解析" class="headerlink" title="resolveDependency 核心解析"></a>resolveDependency 核心解析</h4><ul>
<li><p>解析方法上的字段时：</p>
<ol>
<li><p>首先要获取方法上的名字</p>
<p>当时在获取方法上的名字上，存在JDK版本的限制，在1.7之前，是没有直接的API获取到参数上的具体名字的。所以Spring针对这中情况提供了两种获取方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>1.7：</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111261204806.png" alt="image-20211126120354244"></p>
<blockquote>
<p>在JDK1.7中只有获取参数类型的方法。</p>
</blockquote>
</li>
<li><p>1.8：</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111261216670.png" alt="image-20211126121605973"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111261216683.png" alt="image-20211126121638261"></p>
<blockquote>
<p>所以Spring需要考虑到这种不定的因素，必须自己实现通过局部变量表的方式去获取参数的名字，但是Spring也同时支持JDK自己自己自带的这种获取方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * Spring 自己实现的获取参数名字的方式 * 同时也兼容JDK自带的方式 */</span><span class="function"><span class="keyword">public</span> <span class="title">DefaultParameterNameDiscoverer</span><span class="params">()</span> </span>&#123;   <span class="keyword">if</span> (kotlinPresent) &#123;      addDiscoverer(<span class="keyword">new</span> KotlinReflectionParameterNameDiscoverer());   &#125;   <span class="comment">// JDK自带的方式获取参数名字（需要JDK8以上，并且需要配置编译参数）   addDiscoverer(new StandardReflectionParameterNameDiscoverer());   // 局部变量表的方式获取参数名字   addDiscoverer(new LocalVariableTableParameterNameDiscoverer());&#125;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h5><ol>
<li><p>@Lazy 可以作用在那些上面</p>
<p>@Lazy 可以作用在类上，方法参数上，局部变量上</p>
</li>
<li><p>@Lazy 存在时，对象返回的是什么？</p>
<blockquote>
<p>当存在@Lazy注解时，被该注解标注的Bean对象，是会被返回一个代理独享的，当真正调用该Bean 中的方法时，该Bean 才会通过代理对象，获取该Bean的属性描述，进行初始化，然后调用真正的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;<span class="comment">/**    * 正常情况 真正的解析依赖    */</span>   result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否存在@Lazy 注解</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111261243279.png" alt="判断是否存在@Lazy注解"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111261247163.png" alt="image-20211126124708226"></p>
<p>发现即使存在@Lazy注解，那么在调用真实数据的时候，还是会调用beanFactory.doResolveDependency(descriptor, beanName, null, null);方法。根据依赖描述器进行依赖注入，然后再初始化，再调用真正的方法。</p>
</blockquote>
</li>
</ol>
<ul>
<li>真正的解析依赖</li>
</ul>
<h3 id="真正的解析依赖的方法doResolveDependency"><a href="#真正的解析依赖的方法doResolveDependency" class="headerlink" title="真正的解析依赖的方法doResolveDependency"></a>真正的解析依赖的方法doResolveDependency</h3><p>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br></pre></td></tr></table></figure>

<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><ol>
<li><p>@Value 可以用在那些地方</p>
<p>可以用在变量上，参数上</p>
</li>
</ol>
<p>在解析真正的依赖时，肯定第一步就是判断这些依赖有没有通过@Value注解设置过值的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 注入指定值，QualifierAnnotationAutowireCandidateResolver解析@Value会用到</span></span><br><span class="line">			Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">			<span class="comment">//解析@Value注解</span></span><br><span class="line">			Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">						2.1 占位符解析 （$&#123;&#125;） 这里会在Spring的Environment 中查找</span></span><br><span class="line"><span class="comment">						环境变量包括</span></span><br><span class="line"><span class="comment">							配置文件</span></span><br><span class="line"><span class="comment">							-D 系统参数</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">					BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">						2.2 Spring EL 表达式 (#&#123;&#125;)</span></span><br><span class="line"><span class="comment">							如果是EL 表达式，Spring会根据给定的类型在容器中查找是否存在对应的bean，然后进行赋值</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">					2.3 类型转换</span></span><br><span class="line"><span class="comment">						如果仅仅是一个（“xxx”）字符串的话，或者其他类型，那么spring会判断容器中是否存在对应的类型转换器</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">				<span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">						converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">						converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				3. 集合依赖，如 Array、List、Set、Map。内部查找依赖也是使用findAutowireCandidates</span></span><br><span class="line"><span class="comment">					Map：</span></span><br><span class="line"><span class="comment">						key：必须为String类型</span></span><br><span class="line"><span class="comment">						value：对应类型找到的所有bean</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					List：</span></span><br><span class="line"><span class="comment">						ex：</span></span><br><span class="line"><span class="comment">							object：容器中所有的Bean 都会加载到list中</span></span><br><span class="line"><span class="comment">							T：泛型会报错</span></span><br><span class="line"><span class="comment">							指定类型：Spring会找到容器中所有该类型的Bean</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">			<span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> multipleBeans;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 4. 单个依赖查询 ，  查找匹配到得个数</span></span><br><span class="line">			Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">			<span class="comment">// 4.1 若在容器中没有查找到依赖，判断descriptor.require</span></span><br><span class="line">			<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">// 如果 @autowire 的 require 属性为 true ，但是没有找到相应的匹配项，则抛出异常</span></span><br><span class="line">				<span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				总结：</span></span><br><span class="line"><span class="comment">					Spring 在寻找Bean时，首先是按照类型查找，然后再在结果集里面用beanName类筛选</span></span><br><span class="line"><span class="comment">			 */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>解析@Value 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTest</span> </span>&#123;   <span class="meta">@Autowired</span>   <span class="meta">@Value(&quot;$&#123;xxx&#125;&quot;)</span>   <span class="keyword">private</span> String testBean;   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTestBean</span><span class="params">()</span> </span>&#123;      System.out.println(testBean);   &#125;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>${}占位符的方式</p>
<ol>
<li><p>只有@Value(“${xxx}”)</p>
<blockquote>
<p>输出结果为：${xxx}</p>
</blockquote>
</li>
<li><p>在配置文件中配置了xxx=xiaogang</p>
<blockquote>
<p>输出结果为：xiaogang</p>
</blockquote>
</li>
<li><p>又在系统参数上加了-Dxxx=xiaoganggang</p>
<blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111261348313.png" alt="image-20211126134846950"></p>
<p>输出结果为：xiaoganggang</p>
<p>系统参数的优先级大于配置文件</p>
</blockquote>
</li>
</ol>
</li>
<li><p>EL表达式#{}</p>
<ol>
<li><p>```java<br>@Bean<br>public TestBean xiaogang() {<br>   return new TestBean();<br>}</p>
<pre><code>@Autowired
@Value(&quot;#&#123;xiaogang&#125;&quot;)
private TestBean testBean;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      &gt; 输出结果：真长输出com.iocbeanlifecicle.lg.TestBean@2bea5ab4</span><br><span class="line">   </span><br><span class="line">3. 如果是简单的字符串：</span><br><span class="line"></span><br><span class="line">   1. 如果不存在转换器</span><br><span class="line">   </span><br><span class="line">      ![image-20211126140048451](https://gitee.com/ligangyun/cloudimg/raw/master/img/202111261400972.png)</span><br><span class="line">   </span><br><span class="line">      &gt; 会直接报类型转换错误的异常</span><br><span class="line">   </span><br><span class="line">   2. 编写一个类型转换器试试看呢？</span><br><span class="line">   </span><br><span class="line">      1. 在Spring中使用类型转换器时，表面上是执行的getTypeConvert。但是实际上是通过`PropertyEditorSupport`来实现用户自定义的类型转换的。</span><br><span class="line">   </span><br><span class="line">         ```java</span><br><span class="line">         public class ObjectToValueTypeConverter&lt;T&gt; extends PropertyEditorSupport &#123;</span><br><span class="line">         	Logger logger = Logger.getLogger(ObjectToValueTypeConverter.class.getName());</span><br><span class="line">         </span><br><span class="line">         	@Override</span><br><span class="line">         	public void setAsText(String text) throws IllegalArgumentException &#123;</span><br><span class="line">         		logger.info(&quot;String ----&gt; TestBean is running......&quot;);</span><br><span class="line">         		TestBean testBean = new TestBean();</span><br><span class="line">         		testBean.setName(text);</span><br><span class="line">         		this.setValue(testBean);</span><br><span class="line">         	&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         	@Bean</span><br><span class="line">         	public CustomEditorConfigurer customEditorConfigurer() &#123;</span><br><span class="line">         		CustomEditorConfigurer customEditorConfigurer = new CustomEditorConfigurer();</span><br><span class="line">         		Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; propertyEditorMap = new HashMap&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">         		// 表示StringToUserPropertyEditor可以将String转化成User类型，在Spring源码中，如果发现当前对象是String，而需要的类型是User，就会使用该PropertyEditor来做类型转化</span><br><span class="line">         		propertyEditorMap.put(Json.class, StringToUserPropertyEditor.class);</span><br><span class="line">         </span><br><span class="line">         		// 添加将@Value 是字符串，返回对象是TestBean的转换器</span><br><span class="line">         		propertyEditorMap.put(TestBean.class, ObjectToValueTypeConverter.class);</span><br><span class="line">         </span><br><span class="line">         		customEditorConfigurer.setCustomEditors(propertyEditorMap);</span><br><span class="line">         		return customEditorConfigurer;</span><br><span class="line">         	&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在进行属性注入的时候，解析@Value注入点时，会通过<code>getTypeConverter()</code>一般获取到的都是内部的<code>SimpleTypeConverter</code>，但是由于该类是线程不安全的，所以Spring会在每次工厂进行<code>getTypeConverter()</code>时，返回一个新的对象</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111270811073.png"></p>
<p>寻找用户自定义的类型转换器</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111270820684.png" alt="image-20211127082054305"></p>
<p>这一步将会根据返回类型找到是否存在对应的转换器。</p>
</li>
</ol>
</li>
<li><p>如果返回的对象是集合类型的，Spring底层也会做相对应的操作。</p>
<ol>
<li><p>List 集合</p>
<p>将会返回所有符合该对象的的List集合（从这里就可以看出Spring 在容器中查找Bean的方式首先是以类型去查找的。）</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111270833671.png" alt="image-20211127083353045"></p>
</li>
<li><p>Map集合</p>
<ol>
<li>如果返回的Map集合反应是制定类型，则会返回该类型的所有集合，并且key是其beanName，并且在Spring类型规定，如果 返回的类型是Map，那么Key 必须为String，因为Spring也不能保证key可以为别的什么类型。</li>
</ol>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111270837792.png" alt="image-20211127083705148"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">   ResolvableType mapType = descriptor.getResolvableType().asMap();</span><br><span class="line">   Class&lt;?&gt; keyType = mapType.resolveGeneric(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (String.class != keyType) &#123; <span class="comment">// 如果返回类型补位String，那么直接返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; valueType = mapType.resolveGeneric(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (valueType == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType,</span><br><span class="line">         <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">   <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">      autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> matchingBeans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果返回的类型是Object，</p>
<p>那么将会返回Spring中符合情况的所有Bean。</p>
</li>
<li><p>如果返回类型是泛型。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111270844864.png" alt="image-20211127084402019"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>经过上述一系列操作后，如果返回的结果集是多个的情况下。还要进行一系列的筛选</p>
<ol>
<li><p>如果存在多个Bean的情况下。（并没有指定特定的名字）</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111271250858.png" alt="image-20211127125040268">这种情况下会直接报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error creating bean with name <span class="string">&#x27;valueTest&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;filterService&#x27;</span>; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type <span class="string">&#x27;com.tuling.iocbeanlifecicle.lg.value.FilterService&#x27;</span> available: expected single matching bean but found <span class="number">2</span>: orderFilterServiceImpl,userFilterServiceImpl</span><br></pre></td></tr></table></figure>

<p>这个时候Spring就提供了解决方案，将多个Bean 设置等级。</p>
</li>
<li><p>多个Bean，如果存在<code>@Primary</code>注解，如果不存在<code>@Primary</code>，再解析<code>@Priority</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineAutowireCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">   Class&lt;?&gt; requiredType = descriptor.getDependencyType();</span><br><span class="line">   <span class="comment">// 在多个Bean中筛选出标记了@Primary注解的Bean（标记该注解的Bean 优先级最高）</span></span><br><span class="line">   String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);</span><br><span class="line">   <span class="keyword">if</span> (primaryCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> primaryCandidate;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果不存在@Primary注解，则判断多个Bean中是否设置了优先级@Priority注解</span></span><br><span class="line">   String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);</span><br><span class="line">   <span class="keyword">if</span> (priorityCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> priorityCandidate;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Fallback</span></span><br><span class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">      String candidateName = entry.getKey();</span><br><span class="line">      Object beanInstance = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> ((beanInstance != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.resolvableDependencies.containsValue(beanInstance)) ||</span><br><span class="line">            matchesBeanName(candidateName, descriptor.getDependencyName())) &#123;</span><br><span class="line">         <span class="keyword">return</span> candidateName;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="解析-Primary注解"><a href="#解析-Primary注解" class="headerlink" title="解析@Primary注解"></a>解析@Primary注解</h4><p>​    该注解可以作用在类和方法上的。</p>
<p>​    此时如果存在多个bean，则会判断Bean 是否使用了<code>@Primary</code>注解来标记主要的Bean。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111271403745.png" alt="image-20211127140308147"></p>
<p>该注解在同类型的Bean 中只能存在一个，如果存在多个则会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determinePrimaryCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">   String primaryBeanName = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">      String candidateBeanName = entry.getKey();</span><br><span class="line">      Object beanInstance = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (isPrimary(candidateBeanName, beanInstance)) &#123; <span class="comment">// 判断是否存在@Primary,或者其父类上标注了该注解</span></span><br><span class="line">         <span class="keyword">if</span> (primaryBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> candidateLocal = containsBeanDefinition(candidateBeanName);</span><br><span class="line">            <span class="keyword">boolean</span> primaryLocal = containsBeanDefinition(primaryBeanName);</span><br><span class="line">            <span class="keyword">if</span> (candidateLocal &amp;&amp; primaryLocal) &#123; <span class="comment">// 如果同时存在多个相同的Bean 都存在该注解。则直接报错</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line">                     <span class="string">&quot;more than one &#x27;primary&#x27; bean found among candidates: &quot;</span> + candidates.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (candidateLocal) &#123;</span><br><span class="line">               primaryBeanName = candidateBeanName;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            primaryBeanName = candidateBeanName;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> primaryBeanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析-Priority注解"><a href="#解析-Priority注解" class="headerlink" title="解析@Priority注解"></a>解析@Priority注解</h4><p>作用在类上，来表示优先级可以设置等级排序。（与Order 不同的是，该注解只能作用于此处，并且不能以继承等其他方式呈现，并且Order是在所有的Bean初始化完之后，再根据Order的属性来排序的。两者完全不同）</p>
<p>如果在多个Bean中没有设置了@Primary注解的Bean，则会接着尝试解析@Priority注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineHighestPriorityCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">   String highestPriorityBeanName = <span class="keyword">null</span>;</span><br><span class="line">   Integer highestPriority = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">      String candidateBeanName = entry.getKey();</span><br><span class="line">      Object beanInstance = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">         Integer candidatePriority = getPriority(beanInstance);</span><br><span class="line">         <span class="keyword">if</span> (candidatePriority != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (highestPriorityBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (candidatePriority.equals(highestPriority)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line">                        <span class="string">&quot;Multiple beans found with the same priority (&#x27;&quot;</span> + highestPriority +</span><br><span class="line">                        <span class="string">&quot;&#x27;) among candidates: &quot;</span> + candidates.keySet());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (candidatePriority &lt; highestPriority) &#123;</span><br><span class="line">                  highestPriorityBeanName = candidateBeanName;</span><br><span class="line">                  highestPriority = candidatePriority;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               highestPriorityBeanName = candidateBeanName;</span><br><span class="line">               highestPriority = candidatePriority;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> highestPriorityBeanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>筛选出数字最小的Bean</p>
</blockquote>
<hr>
<h2 id="Spring-到底是怎么通过类型查找到所有的Bean的？findAutowireCandidates-beanName-type-descriptor"><a href="#Spring-到底是怎么通过类型查找到所有的Bean的？findAutowireCandidates-beanName-type-descriptor" class="headerlink" title="Spring 到底是怎么通过类型查找到所有的Bean的？findAutowireCandidates(beanName, type, descriptor)"></a>Spring 到底是怎么通过类型查找到所有的Bean的？findAutowireCandidates(beanName, type, descriptor)</h2><ul>
<li><p>获取所有类型匹配的beanName（这里需要注意的是BeanName而不是Bean，因为可以直接通过beanDefinition来确定Bean的类型是否匹配，而不用额外的创建bean）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">      <span class="keyword">this</span>, requiredType, <span class="keyword">true</span>, descriptor.isEager());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>根据类型获取所有的BeanName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这期间Spring会对BeanDefinitionMap中的所有BeanName进行类型判断</p>
<p>包括：是否为factoryBean的处理逻辑。</p>
<p>其中isTypeMatch(beanName, type);就是来通过类型来判断当前遍历的BeanName是否类型匹配</p>
<ol>
<li><p>判断当前的BeanName 获取单利（在单例池中）</p>
<p>存在</p>
<p>​    判断是否为FactoryBean</p>
<p>​        是：</p>
<p>​            获取FactoryBean需要返回的对象，调用其getType方法</p>
<p>​        不是：</p>
<p>​            直接获取Bean对象</p>
</li>
<li><p>后续还有判断beanName 获取到的类型是否包含泛型，是否尤其父类，其父类是否为FactoryBean的等一系列比较细的判断，并且还会判断beanName如果是以&amp;开头的，那么会判断当前Bean的类型会否为FactoryBean。</p>
</li>
</ol>
<p>最后返回当前beanName是否匹配</p>
</blockquote>
<p>经过这一步就会匹配到所有的bean了（其中是一个Object类，有可能存在Bean没有被实例化，所以包装的beanDefinition）</p>
</li>
</ul>
</li>
<li><p>在获取到所有匹配到的beanName之后（候选人名单），进一步进行判断</p>
<p>循环遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 类型查找：本质上递归调用beanFactory#beanNamesForType。先匹配实例类型，再匹配bd。</span></span><br><span class="line"><span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">   <span class="comment">// 2.1 isSelfReference说明beanName和candidate本质是同一个对象</span></span><br><span class="line">   <span class="comment">//     isAutowireCandidate进一步匹配bd.autowireCandidate、泛型、@Qualifier等进行过滤</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这里Spring有一个原则，如果beanName 匹配出来有多个Bean ，那么优先不会使用自己！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      isAutowireCandidate(candidate, descriptor)</span></span><br><span class="line"><span class="comment">         会判断当前的Bean 是都允许注入的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">      <span class="comment">// 2.2 添加到候选对象中</span></span><br><span class="line">      addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断当前注入的bean是否是自己注入自己"><a href="#判断当前注入的bean是否是自己注入自己" class="headerlink" title="判断当前注入的bean是否是自己注入自己"></a>判断当前注入的bean是否是自己注入自己</h4><ul>
<li><p>判断当前BeanName 是否存在多个Bean，如果存在自己依赖注入自己的情况，会优先考虑别人！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfReferenceTest</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> SelfReferenceTest selfReferenceTest;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSelfReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(selfReferenceTest);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beanName = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;SelfReferenceTest&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;beanName=&#x27;&quot;</span> + beanName +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SelfReferenceTest <span class="title">selfReferenceTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SelfReferenceTest();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：SelfReferenceTest{beanName=’selfReferenceTest1}</p>
</blockquote>
</li>
</ul>
<h4 id="判断当前的Bean-是否支持自动依赖注入"><a href="#判断当前的Bean-是否支持自动依赖注入" class="headerlink" title="判断当前的Bean 是否支持自动依赖注入"></a>判断当前的Bean 是否支持自动依赖注入</h4><ul>
<li><p>接着判断当前BeanName是否是支持依赖注入的</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111280746139.png" alt="image-20211128074627600"></p>
<blockquote>
<p>在Spring 5.1 之后 支持在注解上设置</p>
</blockquote>
<p>Spring 5.1以下，可以通过BeanPostProcessor来实现，（这种情况是需要在Bean的初始化之前设置的，告诉Spring该Bean是不支持自动依赖注入的。）</p>
<p>当存在个Bean 时，直接注入一个类型一样，但是名字不存在Bean时就会报错，但是可以将其中一部分Bean设置为不可注入的对象，只剩下一个Bean对象，这样就不会报错了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TestBean <span class="title">testBean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> TestBean();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TestBean <span class="title">testBean2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> TestBean();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireCandidateTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestBean testBean123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(testBean123);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LgMergedBeanDefinitionPostProcessor</span> <span class="keyword">implements</span> <span class="title">MergedBeanDefinitionPostProcessor</span> </span>&#123;</span><br><span class="line">	Logger logger = Logger.getLogger(LgMergedBeanDefinitionPostProcessor.class.getName());</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 添加在依赖注入时的判断</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;testBean1&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">			logger.info(beanName + <span class="string">&quot;：设置在依赖注入时，不自动注入&quot;</span>);</span><br><span class="line">			beanDefinition.setAutowireCandidate(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时候返回的对象就不会报错了，并且返回容器中唯一的对象（但是目前Spring 5.0这样做会报错）</p>
</blockquote>
<p>责任链模式当前的beanName对应的Bean 是否支持自动注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isAutowireCandidate(candidate, descriptor)</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="params"><span class="function">		DependencyDescriptor descriptor, AutowireCandidateResolver resolver)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">	resolveBeanClass(mbd, beanDefinitionName);</span><br><span class="line">	<span class="keyword">if</span> (mbd.isFactoryMethodUnique) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> resolve;</span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">			resolve = (mbd.resolvedConstructorOrFactoryMethod == <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">			<span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).resolveFactoryMethodIfPossible(mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过责任链的方法判断当前Bean是否可以注入，并且注入的方式是什么</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		SimpleAutowireCandidateResolver（判断autowireCandidate 是否为true） --&gt;</span></span><br><span class="line"><span class="comment">		GenericTypeAwareAutowireCandidateResolver (判断当前Bean 如果是泛型，需要确定其返回的类型)--&gt;</span></span><br><span class="line"><span class="comment">		QualifierAnnotationAutowireCandidateResolver(判断当前Bean 是否使用了@Qualifier注解，如果使用了则进行别名匹配)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> resolver.isAutowireCandidate(</span><br><span class="line">			<span class="keyword">new</span> BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一层 SimpleAutowireCandidateResolver</p>
<p>直接判断autowireCandidate是否为true</p>
</li>
<li><p>第二层 GenericTypeAwareAutowireCandidateResolver判断当前beanName对应的返回类型是否为泛型？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">O</span>, <span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">protected</span> O o;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">protected</span> S s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockService1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">OrderService1</span>, <span class="title">StockService1</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(o);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>当前Bean被注册为一个注入点时，会判断其父类的所有注入点。</p>
<p>所以该Bean就会有两个泛型类型的注入点。</p>
</li>
<li><p>在当前的UserServiceTest中给定了泛型的类型</p>
<p>就可以通过该类获取其父类的泛型类型userServiceTest.getClass().getGenericSuperclass().getTypeName()就可以得到父类中泛型的类型com.iocbeanlifecicle.lg.aotuwire.generictype.BaseService&lt;com.iocbeanlifecicle.lg.aotuwire.generictype.OrderService1, com.iocbeanlifecicle.lg.aotuwire.generictype.StockService1&gt;</p>
</li>
<li><p>再通过父类的泛型，来确定各个变量的具体类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (TypeVariable&lt;? extends Class&lt;?&gt;&gt; typeParameter : userServiceTest.getClass().getSuperclass().getTypeParameters()) &#123;</span><br><span class="line">   System.out.println(typeParameter.getTypeName());</span><br><span class="line">&#125;</span><br><span class="line">O</span><br><span class="line">S</span><br></pre></td></tr></table></figure>

<p>获取与子类中泛型对应的类型。这样一来就可以只在那个泛型具体对应的类型了</p>
</li>
</ol>
</blockquote>
</li>
<li><p>第三层QualifierAnnotationAutowireCandidateResolver 判断是否使用@ Qualifier注解</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="判断-Qualifer-决定beanName具体对应的实例"><a href="#判断-Qualifer-决定beanName具体对应的实例" class="headerlink" title="判断@Qualifer 决定beanName具体对应的实例"></a>判断@Qualifer 决定beanName具体对应的实例</h4><p>​    该逻辑比较简单，类似于在返回Bean的最后异步筛选中，做别名比对。如果使用了该注解，就需要在候选人中选出与其对应的Bean。</p>
<hr>
<p>###AotuwireAnnotationBeanPostProcessor依赖注入流程总结</p>
<p>​    经过这一套流程走下来，@Autowire 依赖注入基本就选出了符合要求的结果了。可以看出在整个Bean类型的确定和筛选中一共经历了六次判断过程。</p>
<ol>
<li><p>首先寻找注入点（@Aotuwire @Value @Inject 都会被认为是注入点）包括方法和属性</p>
<p>Spring内置的依赖注入判断是byName还是byType的方式进行依赖注入时，属性的查找（一般缺省状态下是先通过类型差找出所有的beanDefinition，然后再根据当前给定的beanName进行属性匹配，筛选出最佳的bean）</p>
</li>
<li><p>处理@Value注解</p>
</li>
<li><p>根据Bean的类型将所有的Bean都查询出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">doResolveDependency</span><span class="params">(descriptor, requestingBeanName, autowiredBeanNames, typeConverter)</span></span>;</span><br></pre></td></tr></table></figure>

<p>三层责任链的调用</p>
<ol>
<li>SimpleAutowireCandidateResolver（判断autowireCandidate 是否为true）（1次判断）</li>
<li>GenericTypeAwareAutowireCandidateResolver (判断当前Bean 如果是泛型，需要确定其返回的类型)（2次）</li>
<li>QualifierAnnotationAutowireCandidateResolver(判断当前Bean 是否使用了@Qualifier注解，如果使用了则进行别名匹配)（三次）</li>
</ol>
</li>
<li><p>将筛选过后的bean添加到一个map集合中，key为beanName，value为Object（可能为没有实例化的全限定名）findAutowireCandidates(beanName, type, descriptor);</p>
</li>
<li><p>如果存在多个Bean，进行筛选</p>
<ol>
<li>解析 @Primary注解，取主Bean（4）</li>
<li>解析@Priority注解，取优先级最高的（5）</li>
<li>使用beanName与beanDefinition中的beanName进行匹配（6）</li>
</ol>
</li>
<li><p>通过反射进行属性赋值和方法调用</p>
</li>
</ol>
<h2 id="Resource注解解析"><a href="#Resource注解解析" class="headerlink" title="@Resource注解解析"></a>@Resource注解解析</h2><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281143288.png" alt="image-20211128114326798"></p>
<ol>
<li><p>先执行findResourceMetadata(beanName, beanType, null);寻找@Resource的注入点</p>
</li>
<li><p>与Autowire不同的是，@Resource是在InstantiationAwareBeanPostProcessor.postProcessPropertyValues中进行的依赖注入的</p>
</li>
<li><p>判断该注解是否存在name</p>
<ol>
<li><p>没有</p>
<p>逻辑与Autowire一致，先byType再byName</p>
</li>
<li><p>如果存在</p>
<p>就会根据name去匹配对应的Bean，如果不存在则会直接报错。</p>
</li>
</ol>
</li>
</ol>
<h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281442748.png" alt="image-20211128144221340"></p>
<blockquote>
<p>当前的状态就是循环的Bean是一个闭环，没办法进行的。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281456898.png" alt="image-20211128145601510"></p>
<p><font color="red">所以现在是A和B出现了循环依赖，这种情况就需要Spring的逻辑来解决这种情况</font></p>
<p>Spring提供了这种情况的解决思路，就是打破创建Bean的闭环</p>
<p>三级缓存是通用的叫法。</p>
<ul>
<li>一级缓存为：singletonObjects<ul>
<li>●singletonObjects中缓存的是已经经历了完整生命周期的bean对象。</li>
</ul>
</li>
<li>二级缓存为：earlySingletonObjects<ul>
<li>●earlySingletonObjects比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入了earlySingletonObjects。</li>
</ul>
</li>
<li>三级缓存为：singletonFactories<ul>
<li>●singletonFactories中缓存的是ObjectFactory，表示对象工厂，表示用来创建早期bean对象的工厂。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="打破循环依赖的闭环，加入缓存"><a href="#打破循环依赖的闭环，加入缓存" class="headerlink" title="打破循环依赖的闭环，加入缓存"></a>打破循环依赖的闭环，加入缓存</h2><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281458173.png" alt="image-20211128145818113"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281513756.png" alt="image-20211128151353304"></p>
<blockquote>
<p>引入一个缓存就可以解决上述bean发生循环依赖的闭环导致的问题。</p>
<p><font color="red">问题又来了：如果在B在bean的生命周期中，在初始化后，需要进行AOP增强的话。生成了新的代理对象，但是此时在缓存中还是一个B的原始对象，并不能替换为代理对象，虽然这也是一种情况，但是貌似一种缓存也还是能满足的，在AOP之后，将生成的代理对象设置回缓存，并且放到单例池中，但是如果此时A对象在初始化后要进行AOP呢？那么生成的B对象是不是又要重新赋值呢？</font></p>
</blockquote>
<h2 id="在实例化时，进行AOP提前生成代理对象"><a href="#在实例化时，进行AOP提前生成代理对象" class="headerlink" title="在实例化时，进行AOP提前生成代理对象"></a>在实例化时，进行AOP提前生成代理对象</h2><p>​    这种处理方式就可以解决在Bean的循环依赖中，如果出现了在初始化后需要进行AOP的话导致缓存中的原始对象过期的现象。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281527280.png" alt="image-20211128152705810"></p>
<blockquote>
<p>这种方式，只需要一个map缓存就可以实现了，为什么Spring 要使用三层缓存呢？</p>
<p><font color = 'red'>问题：在Bean的生成周期中，一般AOP都是发生在初始化后的。</font></p>
</blockquote>
<h2 id="在出现循环依赖时，将AOP提前到实例化中进行"><a href="#在出现循环依赖时，将AOP提前到实例化中进行" class="headerlink" title="在出现循环依赖时，将AOP提前到实例化中进行"></a>在出现循环依赖时，将AOP提前到实例化中进行</h2><p><strong>提前</strong></p>
<p>​    所以是需要有一个判断标砖的，来判断当前Bean是否出现了循环依赖。所以Spring引入了第二级缓存</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281539644.png" alt="image-20211128153951243"></p>
<h2 id="Spring在什么时候判断Bean-是否出现了循环依赖呢？"><a href="#Spring在什么时候判断Bean-是否出现了循环依赖呢？" class="headerlink" title="Spring在什么时候判断Bean 是否出现了循环依赖呢？"></a>Spring在什么时候判断Bean 是否出现了循环依赖呢？</h2><p>​    显然最好是在填充属性时，进行判断当前依赖的Bean 是否出现了循环依赖</p>
<blockquote>
<p>在Spring中引入了一个set集合在bean实例化之前，将创建的Bena 存在Set中标记为当前Bean正在创建中。</p>
<p>如果在进行填充属性时，发现当前的依赖的Bean 在该Set集合中存在，那么就证明该集合中的Bean出现了循环依赖</p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281603553.png" alt="image-20211128160315118"></p>
<blockquote>
<p>这样看上去就解决了循环依赖了。</p>
<p><font color = 'red'>问题：如果此时A又依赖了一个C，并且C也依赖了A呢？是不是就出现了生成两个AOP代理对象呢？</font></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281609557.png" alt="image-20211128160916995"></p>
</blockquote>
<h3 id="引入二级缓存解决，AOP代理对象重复创建的问题"><a href="#引入二级缓存解决，AOP代理对象重复创建的问题" class="headerlink" title="引入二级缓存解决，AOP代理对象重复创建的问题"></a>引入二级缓存解决，AOP代理对象重复创建的问题</h3><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281618300.png" alt="image-20211128161810769"></p>
<blockquote>
<p><font color = 'red'>问题：那么引入的二级缓存肯定不是值缓存AOP代理对象的，因为循环依赖发生的害死时候，不一定就会要AOP。</font></p>
</blockquote>
<h3 id="二级缓存也需要将原始对象存入"><a href="#二级缓存也需要将原始对象存入" class="headerlink" title="二级缓存也需要将原始对象存入"></a>二级缓存也需要将原始对象存入</h3><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281641025.png" alt="image-20211128164149521"></p>
<blockquote>
<p>这样一来，就解决了多个Bean循环依赖的问题，那么为什么要引入第三级缓存呢？</p>
<p><font color = 'red'>问题：就是在判断是否需要AOP时，如何进行判断的问题。</font></p>
<p>在Spring中，是通过BeanPostProcessor的扩展点的方式进行的，并且在上图分析的流程中，beanMap就是传说中的第三级缓存，就是用来标记创建的Bean的原始类型的。方便在解决循环依赖时是否需要进行AOP的。</p>
<p>如果不需要AOP直接在Bean中获取原始对象就可以了</p>
<p>如果需要，则创建AOP就可以了。但是创建的AOP又要考虑到代理对象中的target的问题。</p>
<p>但是在这个地方进行AOP或者判断又违背了Bean的生命周期，因为Bean的生命周期中Bean的AOP是在初始化后进行的。</p>
<p>所以Spring 将第三级缓存设计成了传入lambda表达式的方式进行判断的。</p>
<p>所有的判断逻辑都是由lambda表达式自己完成。</p>
</blockquote>
<h2 id="引入三级缓存实现AOP自我判断"><a href="#引入三级缓存实现AOP自我判断" class="headerlink" title="引入三级缓存实现AOP自我判断"></a>引入三级缓存实现AOP自我判断</h2><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111281656210.png" alt="image-20211128165559797"></p>
<blockquote>
<p>在经过第三级缓存时，不管返回的是否为AOP代理对象都将会存入到二级缓存中。原因就是当前返回的Bean对象都是残缺的，都没有经过完整的生命周期的。</p>
</blockquote>
<h3 id="为什么要引入第三级缓存呢？"><a href="#为什么要引入第三级缓存呢？" class="headerlink" title="为什么要引入第三级缓存呢？"></a>为什么要引入第三级缓存呢？</h3><p><strong>首先明确一点，每一个Bean都会遵循Spring的生命周期，但是当<font color='red'>出现循环依赖时</font>并且还需要进行AOP时<font color='red'>才会通过Lambda的方式提前AOP创建动态代理</font>打破SpringBean的生命周期</strong></p>
<ul>
<li><p>尝试如果不通过第三级缓存来管理AOP的创建情况的话</p>
<p>为什么需要<strong>singletonFactories</strong>？假设没有<strong>singletonFactories</strong>，只有<strong>earlySingletonObjects</strong>，earlySingletonObjects是二级缓存，它内部存储的是未经过完整生命周期的bean对象，Spring原有的流程是出现了循环依赖的情况下：</p>
<ol>
<li>先从singletonFactories中拿到lambda表达式，这里肯定是能拿到的，因为每个bean<strong>实例化之后</strong>，<strong>依赖注入之前</strong>，就会生成一个lambda表示放入singletonFactories中</li>
<li>执行lambda表达式，得到结果，将结果放入earlySingletonObjects中</li>
</ol>
</li>
<li><p>那么如果没有<strong>singletonFactories</strong>，Spring 怎样将没有经过完整的生命周期的Bean存入到二级缓存<strong>earlySingletonObjects</strong>呢？</p>
<ol>
<li>如果不存在第三级缓存，那么如果做AOP判断的话，在Bean实例化后，依赖注入前。每一个Bean都要提前做AOP，这样明显是不符合Spring的生命周期的。</li>
<li>如果此时发现真的有Bean产生了循环依赖的话，那么怎么确定当前的Bean是需要AOP的呢？如果不需要AOP，那么怎么拿到原始对象呢？最重要的是，如果需要AOP，那么是怎么获取到target方法呢？这是最重要的，虽然可以使用最土的方法是将所有的情况都存在一个集合中，类似于一级缓存，这样的代码实在是太蠢了。</li>
</ol>
<p><font color='red'>所以目前第三级缓存明显是最重要的，是循环依赖中最靠谱的兜底方案，并且还优雅的解决了在不需要AOP时，不会打乱Bean的生命周期的情况</font></p>
</li>
</ul>
<h2 id="循环依赖都是原型Bean，Spring可以解决嘛？"><a href="#循环依赖都是原型Bean，Spring可以解决嘛？" class="headerlink" title="循环依赖都是原型Bean，Spring可以解决嘛？"></a>循环依赖都是原型Bean，Spring可以解决嘛？</h2><p>​    不可以</p>
<h2 id="循环依赖中两个中有一个是单例Bean，Spring可以解决嘛？"><a href="#循环依赖中两个中有一个是单例Bean，Spring可以解决嘛？" class="headerlink" title="循环依赖中两个中有一个是单例Bean，Spring可以解决嘛？"></a>循环依赖中两个中有一个是单例Bean，Spring可以解决嘛？</h2><p>​    可以，无非可能要多循环几次，因为单例Bean 是遵循Spring的生命周期的</p>
<h2 id="循环依赖中，构造方法循环依赖，Spring能够解决嘛？"><a href="#循环依赖中，构造方法循环依赖，Spring能够解决嘛？" class="headerlink" title="循环依赖中，构造方法循环依赖，Spring能够解决嘛？"></a>循环依赖中，构造方法循环依赖，Spring能够解决嘛？</h2><p>​    构造方法，在进入到Spring 创建Bean 生命周期中的第一步都走不下去，在创建Bean的时候就已经报错了。</p>
<p><font color='red'>但是在Spring的生命周期中，出现的循环依赖的问题大多数可以使用@Lazy来解决。</font></p>
<p>因为使用@Lazy注解是，在解析该注解的时候，Spring会创建其代理对象。这样依赖变相的将解决了构造器循环依赖的问题了！！！！</p>
<h2 id="Transaction和-Aysnc-注解的区别"><a href="#Transaction和-Aysnc-注解的区别" class="headerlink" title="@Transaction和@Aysnc 注解的区别"></a>@Transaction和@Aysnc 注解的区别</h2><p>​    Transaction不是通过后置处理器的方式实现的，所以不会每个Bean都执行的。但是@Aysnc则是通过后置处理器的方式实现的。所以像AOP一样，是需要生成代理对象的，那么该代理对象是需要考虑依赖注入的环境的。</p>
<p>​    所以在异步循环依赖中，也可以使用@Lazy注解通过先生成代理对象来实现类似于解决依赖注入的方式的。</p>
<h2 id="自己注入自己算是循环依赖嘛？"><a href="#自己注入自己算是循环依赖嘛？" class="headerlink" title="自己注入自己算是循环依赖嘛？"></a>自己注入自己算是循环依赖嘛？</h2><p>​    也算的，也是通过三层缓存来实现的</p>
<h2 id="循环依赖的核心逻辑，在是个9年用于迎来更新，都更新了那些内容呢？"><a href="#循环依赖的核心逻辑，在是个9年用于迎来更新，都更新了那些内容呢？" class="headerlink" title="循环依赖的核心逻辑，在是个9年用于迎来更新，都更新了那些内容呢？"></a>循环依赖的核心逻辑，在是个9年用于迎来更新，都更新了那些内容呢？</h2><p>​    因为在老的实现中，可能存在死锁的情况（虽然Spring 在多线程的情况下特别是结合内部大量使用锁的情况下有一定的概率出现死锁的情况的。）所以在最近的5.3.10中对该方法的加锁方式进一步的细化了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Spring 5.3.13 中的实现，将锁更加细化了	</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">					<span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">					singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">						<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">							ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">							<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">								singletonObject = singletonFactory.getObject();</span><br><span class="line">								<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">								<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/pull/26376">https://github.com/spring-projects/spring-framework/pull/26376</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/issues/25667">https://github.com/spring-projects/spring-framework/issues/25667</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/issues/13117">https://github.com/spring-projects/spring-framework/issues/13117</a></p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>在Spring解决循环依赖中，大致的思想史，在每一个Bean进行实例化之前，都会将自己存入到一个正在创建的集合中，方便后续判断<code>singletonsCurrentlyInCreation SET集合</code></li>
<li>在实例化后，依赖注入之前，会给每一个Bean生成一个<code>ObjectFactory</code>类型的Lambda表达式，并且加上名字一起存在第三级缓存中<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code> <strong>该集合是永远的兜底，因为当每一个Bean是单例的，并且支持依赖注入，当前beanName是否已经被标记为正在创建了，就会执行这一步</strong></li>
<li>当存在依赖注入时，不管是根据什么获取Bean，都会调用getBean的逻辑。那么就会尝试在单例池中获取对象getSingleton(String beanName)（<code> Map&lt;String, Object&gt; singletonObjects</code>）</li>
<li>如果在单例池中没有获取到,并且当前类已经被标记为正在创建了（说明出现了循环依赖），则尝试在二级缓存中获取<code>Map&lt;String, Object&gt; earlySingletonObjects</code></li>
<li>如果二级缓存中还没有获取到，则会在三级缓存中获取，会执行在第一步中传入的Lambda表达式<code>getEarlyBeanReference(beanName, mbd, bean)</code>，这是就会判断是否需要生成代理对象等。然后将<strong>生成的对象存到第二级缓存中</strong>并且将三级缓存中的beanName对应的lambda表达移除，如果生成AOP代理对象，还会将生成的对象存在一个代理引用的集合中<code> Map&lt;Object, Object&gt; earlyProxyReferences</code>用于标记当前类进行生成过代理对象了。</li>
<li>再进行后续的初始化等Bean生命周期操作，将二级缓存中的残疾Bean都生成完成的Bean之后移除，并且添加到一级缓存中</li>
</ol>
<blockquote>
<p><strong>总结Spring中三个缓存的作用</strong></p>
<ul>
<li><p>一级缓存 ：singletonObjects</p>
<p>存放走完完整的Bean生命周期的Bean</p>
</li>
<li><p>二级缓存：earlySingletonObjects</p>
<p>存放所有生成的中间类，为走位完整的生命周期的Bean</p>
</li>
<li><p>三级缓存：singletonFactories</p>
<p>存放的是每一个Bean，可能存在AOP代理的最优解决思路，将判断是否需要AOP的操作交由Lambda决定，只有真正需要AOP时，才会打破Bean的生命周期</p>
</li>
</ul>
</blockquote>
<h1 id="Spring-的推断构造"><a href="#Spring-的推断构造" class="headerlink" title="Spring 的推断构造"></a>Spring 的推断构造</h1><ol>
<li>默认情况，用无参构造方法，或者只有一个构造方法就用哪一个</li>
<li>程序员制定了构造方法入参值，通过getBean()或者BeanDefinition.getConstructorArgumentValues()制定，那就用锁匹配的构造方法</li>
<li>程序员想让Spring自动选择构造方法以及构造方法的入参值，autowire=“constructor”</li>
<li>程序员通过@Autowired注解制定了某个构造方法，但希望Spring自动找该构造方法的入参值</li>
</ol>
<p>TODO</p>
<h1 id="Spring-的启动源码"><a href="#Spring-的启动源码" class="headerlink" title="Spring 的启动源码"></a>Spring 的启动源码</h1><p>​    通常说到Spring源码的启动，就是读取配置文件，然后再执行refresh()。但是Spring在这之前还做了大量的预备动作</p>
<ol>
<li><p>构造一个BeanFactory对象。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111291508267.png" alt="image-20211129150813314"></p>
<blockquote>
<p>这里创建出来的BeanFactory对象除了做一些赋值操作外，还会做一个动作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>();</span><br><span class="line">   ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">   ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">   ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>解析所有的配置类，将配置全部解析为beanDefinition，并且注册到上面生成的beanFactory中。</p>
</li>
</ol>
<h3 id="问题：如何在Spring启动时，判断容器中的环境变量"><a href="#问题：如何在Spring启动时，判断容器中的环境变量" class="headerlink" title="问题：如何在Spring启动时，判断容器中的环境变量"></a>问题：如何在Spring启动时，判断容器中的环境变量</h3><p>​    可以通过Environment去设置启动参数的。这一步会在refresh的第一步中检测是否在环境变脸各种设置了启动参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">context.register(StartConfig.class);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   这里有一个在源码中找方法的技巧，在源码中的方法是getEnvironment().validateRequiredProperties();</span></span><br><span class="line"><span class="comment">   并且也是基于当前的beanFactory操作的，所以如果要设置一个值，先模仿源码中获取到环境变量就可以做相对应的设置操作了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">context.getEnvironment().setRequiredProperties(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在配置文件中或者在启动参数中设置</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111291553964.png" alt="image-20211129155327548"></p>
</blockquote>
<h3 id="Spring通过模板方法实现了对容器的不同实现，能否重复刷新的问题"><a href="#Spring通过模板方法实现了对容器的不同实现，能否重复刷新的问题" class="headerlink" title="Spring通过模板方法实现了对容器的不同实现，能否重复刷新的问题"></a>Spring通过模板方法实现了对容器的不同实现，能否重复刷新的问题</h3><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111291554835.png" alt="image-20211129155457467"></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext 实现了GenericApplicationContext（不支持重复刷新）</span><br><span class="line">AnnotationConfigWebApplicationContext 实现了AbstractRefreshableWebApplicationContext（支持刷新）</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>AnnotationConfigApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">context.register(StartConfig.class);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   重复刷新的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">context.refresh();</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202111291559961.png" alt="image-20211129155949370"></p>
</li>
</ul>
<h1 id="Spring-解析配置流程"><a href="#Spring-解析配置流程" class="headerlink" title="Spring 解析配置流程"></a>Spring 解析配置流程</h1><h1 id="Spring整合MyBatis-底层源码"><a href="#Spring整合MyBatis-底层源码" class="headerlink" title="Spring整合MyBatis 底层源码"></a>Spring整合MyBatis 底层源码</h1><h2 id="手写MyBatis整合流程"><a href="#手写MyBatis整合流程" class="headerlink" title="手写MyBatis整合流程"></a>手写MyBatis整合流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Select(&quot;select, &#x27;user&#x27;&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">selectById</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(userMapper.selectById());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainStart</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"></span><br><span class="line">		UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">		userService.test();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果 </span></span><br><span class="line"><span class="comment">// No qualifying bean of type &#x27;com.assumejson.mapper.UserMapper&#x27; available</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果肯定是找不到该类的。很明显，Spring 在加载BeanDefinition的时候，扫描类时，会直接跳过接口的，默认认为接口是不可以被实例化的。</p>
<p><font color='red'>原因就是该Mapper 现在并不能被Spring识别成一个BeanDefinition，那么首先得要想办法将该Bean生成一个BeanDefinition</font></p>
</blockquote>
<h3 id="尝试将Mapper-注册到BeanDefinitionMap中去"><a href="#尝试将Mapper-注册到BeanDefinitionMap中去" class="headerlink" title="尝试将Mapper 注册到BeanDefinitionMap中去"></a>尝试将Mapper 注册到BeanDefinitionMap中去</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainStart</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">		context.register(AppConfig.class);</span><br><span class="line"></span><br><span class="line">		AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition.setBeanClass(UserMapper.class);</span><br><span class="line">		context.registerBeanDefinition(<span class="string">&quot;userMapper&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">		context.refresh();</span><br><span class="line"></span><br><span class="line">		UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">		userService.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果：</p>
<p>​    显然这种方式还是会报错，因为Sring根本就不支持注册接口类。</p>
<p>现在这种方式需要使用FactoryBean 对Mapper接口进行动态代理。</p>
</blockquote>
<blockquote>
<p><font color='red'>那么第一个需要解决的问题就是Spring如何将Mapper 接口添加到BeanDefinitionMap中，肯定的需要生成代理对象了吧。那么使用FactoryBean进行包装呢？在FactoryBean的时候返回代理对象。</font></p>
</blockquote>
<h3 id="使用FactoryBean-进行包装Mapper接口"><a href="#使用FactoryBean-进行包装Mapper接口" class="headerlink" title="使用FactoryBean 进行包装Mapper接口"></a>使用FactoryBean 进行包装Mapper接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapperFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Object proxyInstance = Proxy.newProxyInstance(MyMapperFactoryBean.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;UserMapper.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				System.out.println(method.getName());</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> proxyInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> UserMapper.class;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种情况需要将上面定义的BeanDefinition 注释掉，不然在还没有运行到FactoryBean回调时，就注册了该接口的BeanDefinition，会报错！</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果：</p>
<p>selectById</p>
<p>null</p>
<p><strong>显然</strong></p>
<p>​    Mapper的代理对象在容器中是已经生成了，但是问题又来了，如果有多个Mapper需要解析呢？这种写死的方式显然不可能的</p>
<p>​    Mybatis-Spring在底层是怎么动态的识别Mapper 的呢？</p>
<p><font color='red'>那么是不是可以在FactoryBean中定义一个变量，在构造方法的时候动态的制定代理类的类型呢？</font></p>
</blockquote>
<h3 id="使用FactoryBean的构造参数，动态定义代理对象"><a href="#使用FactoryBean的构造参数，动态定义代理对象" class="headerlink" title="使用FactoryBean的构造参数，动态定义代理对象"></a>使用FactoryBean的构造参数，动态定义代理对象</h3><p>​    在上面的情况中，只能依赖Bean 生命周期中使用FactoryBean进行回调，对接口对象生成代理类，但是如果代码是写死的，如果多出几个Mapper接口怎么办呢？那么是不是可以将FactoryBean 注册成BeanDefinition，并且BeanName是以mapper接口名字来区分的呢？并且FactoryBean构造方法的入参也可以设置成动态的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapperFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Class interFaceClass;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyMapperFactoryBean</span><span class="params">(Class interFaceClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.interFaceClass = interFaceClass;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object proxyInstance = Proxy.newProxyInstance(MyMapperFactoryBean.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;interFaceClass&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				System.out.println(method.getName() + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> proxyInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> interFaceClass;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainStart</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">		context.register(AppConfig.class);</span><br><span class="line">		<span class="comment">// 将接口Mapper 注册成DeanDefinition</span></span><br><span class="line">		AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition.setBeanClass(MyMapperFactoryBean.class);</span><br><span class="line">		beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);</span><br><span class="line">		context.registerBeanDefinition(<span class="string">&quot;userMapper&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">		AbstractBeanDefinition beanDefinition1 = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition1.setBeanClass(MyMapperFactoryBean.class);</span><br><span class="line">		beanDefinition1.getConstructorArgumentValues().addGenericArgumentValue(OrderMapper.class);</span><br><span class="line">		context.registerBeanDefinition(<span class="string">&quot;orderMapper&quot;</span>, beanDefinition1);</span><br><span class="line"></span><br><span class="line">		context.refresh();</span><br><span class="line"></span><br><span class="line">		UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">		userService.test();</span><br><span class="line"></span><br><span class="line">		userService.test1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果：</p>
<p>selectById running</p>
<p>null<br>selectById running<br>null</p>
<p><font color='red'>但是这种情况实现非常的不友好，不可能所有的Mapper 都要用户去定义BeanDefinition，那样就失去了IoC的初衷了。</font></p>
<p>引入 BeanDefinitionRegistryPostProcessor</p>
</blockquote>
<h3 id="使用BeanDefinitionRegistryPostProcessor-进行注册BeanDefinition"><a href="#使用BeanDefinitionRegistryPostProcessor-进行注册BeanDefinition" class="headerlink" title="使用BeanDefinitionRegistryPostProcessor 进行注册BeanDefinition"></a>使用BeanDefinitionRegistryPostProcessor 进行注册BeanDefinition</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapperBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// 将接口Mapper 注册成DeanDefinition</span></span><br><span class="line">		AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition.setBeanClass(MyMapperFactoryBean.class);</span><br><span class="line">		beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);</span><br><span class="line">		registry.registerBeanDefinition(<span class="string">&quot;userMapper&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">		AbstractBeanDefinition beanDefinition1 = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition1.setBeanClass(MyMapperFactoryBean.class);</span><br><span class="line">		beanDefinition1.getConstructorArgumentValues().addGenericArgumentValue(OrderMapper.class);</span><br><span class="line">		registry.registerBeanDefinition(<span class="string">&quot;orderMapper&quot;</span>, beanDefinition1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式看上去优雅了不少，但是还是有问题存在，这里的接口代码还是写死的，如果再增加或者删除接口呢？</p>
<p><font color='red'>代码还是写死的，使用扫描机制进行包扫描</font></p>
</blockquote>
<h3 id="使用扫描进行Mapper-的扫描实现动态增删Mapper-代理对象"><a href="#使用扫描进行Mapper-的扫描实现动态增删Mapper-代理对象" class="headerlink" title="使用扫描进行Mapper 的扫描实现动态增删Mapper 代理对象"></a>使用扫描进行Mapper 的扫描实现动态增删Mapper 代理对象</h3><p>​    那么问题来了，扫描用什么来扫描呢？在当前类中并没有提供可以扫描注解的工具。这里就可以模仿Spring 实现中的。在BeanDefinitionRegistryPostProcessor中使用@Import注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MyImportBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMapperScan &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 扫描,@Import注解在那个类上，Spring会将解析该类时的信息携带进来，执行该方法，就非常方便的获取扫描路径了</span></span><br><span class="line">		Map&lt;String, Object&gt; myMapperScan = importingClassMetadata.getAnnotationAttributes(MyMapperScan.class.getName());</span><br><span class="line">		String path = (String) myMapperScan.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(path);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将接口Mapper 注册成DeanDefinition</span></span><br><span class="line">		AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition.setBeanClass(MyMapperFactoryBean.class);</span><br><span class="line">		beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);</span><br><span class="line">		registry.registerBeanDefinition(<span class="string">&quot;userMapper&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">		AbstractBeanDefinition beanDefinition1 = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition1.setBeanClass(MyMapperFactoryBean.class);</span><br><span class="line">		beanDefinition1.getConstructorArgumentValues().addGenericArgumentValue(OrderMapper.class);</span><br><span class="line">		registry.registerBeanDefinition(<span class="string">&quot;orderMapper&quot;</span>, beanDefinition1);</span><br><span class="line"></span><br><span class="line">		ImportBeanDefinitionRegistrar.<span class="keyword">super</span>.registerBeanDefinitions(importingClassMetadata, registry, importBeanNameGenerator);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果：</p>
<p>com.assumejson.mapper<br>selectById running<br>null<br>selectById running<br>null</p>
<p>这里就可以看到@Import的妙用了。</p>
<p>接下来使用Spring内部的扫描器就可以得到结果，但是<font color='red'>Spring 中的扫描器只会关心是不是类，会跳过接口，但是Mybatis 中指关心接口，那么怎么办呢？那就重写Spring中的扫描器</font></p>
</blockquote>
<h3 id="重写Spring的扫描器，实现只扫描接口类型"><a href="#重写Spring的扫描器，实现只扫描接口类型" class="headerlink" title="重写Spring的扫描器，实现只扫描接口类型"></a>重写Spring的扫描器，实现只扫描接口类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyMapperScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写Spring 的扫描逻辑，修改为只关心接口类型</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanDefinition the bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 只要是接口类型，就返回true</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> beanDefinition.getMetadata().isInterface();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 扫描,@Import注解在那个类上，Spring会将解析该类时的信息携带进来，执行该方法，就非常方便的获取扫描路径了</span></span><br><span class="line">		Map&lt;String, Object&gt; myMapperScan = importingClassMetadata.getAnnotationAttributes(MyMapperScan.class.getName());</span><br><span class="line">		String path = (String) myMapperScan.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">		MyMapperScanner scanner = <span class="keyword">new</span> MyMapperScanner(registry);</span><br><span class="line">		scanner.scan(path);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将接口Mapper 注册成DeanDefinition</span></span><br><span class="line">		AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition.setBeanClass(MyMapperFactoryBean.class);</span><br><span class="line">		beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);</span><br><span class="line">		registry.registerBeanDefinition(<span class="string">&quot;userMapper&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">		AbstractBeanDefinition beanDefinition1 = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">		beanDefinition1.setBeanClass(MyMapperFactoryBean.class);</span><br><span class="line">		beanDefinition1.getConstructorArgumentValues().addGenericArgumentValue(OrderMapper.class);</span><br><span class="line">		registry.registerBeanDefinition(<span class="string">&quot;orderMapper&quot;</span>, beanDefinition1);</span><br><span class="line"></span><br><span class="line">		ImportBeanDefinitionRegistrar.<span class="keyword">super</span>.registerBeanDefinitions(importingClassMetadata, registry, importBeanNameGenerator);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>debug 运行查看获取到的BeanDefinition，发现并没有获取到定义的Mapper，发现源码中是这样写的：</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112081500106.png" alt="image-20211208150008709"></p>
<p><font color='red'>重写该判断</font></p>
</blockquote>
<h3 id="重写Spring扫描的过滤条件"><a href="#重写Spring扫描的过滤条件" class="headerlink" title="重写Spring扫描的过滤条件"></a>重写Spring扫描的过滤条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 除了重写外，Spring还提供了一个API可以使用，就是使用scanner 添加一个过滤条件</span></span><br><span class="line">		scanner.addIncludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将所有扫描到的类都返回true。</p>
<p><font color='red'>问题又来了，扫描出来的BeanDefinition 都是接口类型的，我们需要返回代理对象啊！</font></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112081504373.png" alt="image-20211208150437973"></p>
</blockquote>
<h3 id="重写Spring-doscan方法，定制BeanDefinition"><a href="#重写Spring-doscan方法，定制BeanDefinition" class="headerlink" title="重写Spring doscan方法，定制BeanDefinition"></a>重写Spring doscan方法，定制BeanDefinition</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">			BeanDefinition beanDefinition = beanDefinitionHolder.getBeanDefinition();</span><br><span class="line">			beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanDefinition.getBeanClassName());</span><br><span class="line">			beanDefinition.setBeanClassName(MyMapperFactoryBean.class.getName());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> beanDefinitionHolders;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 扫描,@Import注解在那个类上，Spring会将解析该类时的信息携带进来，执行该方法，就非常方便的获取扫描路径了</span></span><br><span class="line">		Map&lt;String, Object&gt; myMapperScan = importingClassMetadata.getAnnotationAttributes(MyMapperScan.class.getName());</span><br><span class="line">		String path = (String) myMapperScan.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">		MyMapperScanner scanner = <span class="keyword">new</span> MyMapperScanner(registry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		scanner.addIncludeFilter(new TypeFilter() &#123;</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;</span></span><br><span class="line"><span class="comment">//				return true;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;);</span></span><br><span class="line"></span><br><span class="line">		scanner.scan(path);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112081512573.png" alt="image-20211208151225262"></p>
<p>现在就可以实现，在制定路径下，仍以添加Mapper 接口，并且自动扫描，自动代理了。</p>
<p><font color='red'>问题来了，现在代理对象相当于是Spring自己写的，正常情况下，肯定是需要Mybatis 自己写代理对象的，</font></p>
</blockquote>
<h3 id="注入Mybatis-Factory-进行Mapper-代理"><a href="#注入Mybatis-Factory-进行Mapper-代理" class="headerlink" title="注入Mybatis Factory 进行Mapper 代理"></a>注入Mybatis Factory 进行Mapper 代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在MyBatis 中操作SQL的是一个SqlSession对象。所以可以直接在代理类中传入一个SqlSession对象，代理交给他就可以了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapperFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Class interFaceClass;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyMapperFactoryBean</span><span class="params">(Class interFaceClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.interFaceClass = interFaceClass;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sqlSession.getMapper(interFaceClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> interFaceClass;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样代理逻辑就只有一行了，但是Sqlsession怎么传进去呢？</p>
<p>​    在使用MyBatis 时，都是使用SqlSessionFactory调用sqlSessionFactory.openSession()来获取sqlSession的。那么只需要在容器中存在sqlSessionFactory对象就可以实现了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapperFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Class interFaceClass;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyMapperFactoryBean</span><span class="params">(Class interFaceClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.interFaceClass = interFaceClass;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sqlSession.getMapper(interFaceClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> interFaceClass;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么如果在容器中生成SqlSessionFactory对象呢？ 这就需要用户自己定义了，在使用MyBatis时，通常都需要读取一个mybatis.xml的配置文件，用来连接数据库，生成SqlSessionFactory。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;mybatis.xml&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果：</p>
<p>user</p>
<p>order<br>member</p>
</blockquote>
<p><strong>总结</strong></p>
<p>​    Spring 整合第三方框架的核心原理，就是将第三方框架中干事的对象都放到Spring 容器中进行管理。这样一来就可以很方便的管理这些bean，并且也能非常方便的使用这些框架的功能了。</p>
<h2 id="Spring-整合MyBatis-的源码流程"><a href="#Spring-整合MyBatis-的源码流程" class="headerlink" title="Spring 整合MyBatis 的源码流程"></a>Spring 整合MyBatis 的源码流程</h2><ol>
<li><p>首先通过@MapperScan注解进行扫描，其中有@Improt 注解，Spring会接续导入的类，调用实现的<code>ImportBeanDefinitionRegistrar</code>的<code>registerBeanDefinitions</code></p>
<blockquote>
<p>Spring 在解析每一个注解的时候都会判断该注解上面是否存在@Improt注解，如果存在，则会执行该类，执行其实现的<code>registerBeanDefinitions</code>方法。跟自己实现的方法一样的操作 ，这种方式与<code>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</code>比较，该回调功能比较单例只是提供了Bean的注册的功能，但是针对于@Improt 注解的回调，都会携带上该注解的类的所有元信息，所以操作起来会非常的方便并且直观。在Mybatis 源码引入的实现中就是利用了这种方式进行植入的。</p>
</blockquote>
</li>
<li><p>在执行该方法时，与我们写的一样，Mybatis 构建了一个<code>ClassPathMapperScanner</code>  也是继承了<code>ClassPathBeanDefinitionScanner</code>，在我们的实现中，会重写其过滤规则，并且Spring只会关注类，而Mybatis 恰恰相反只关心接口，所以该方法也需要重写。</p>
<blockquote>
<p>在扫描之后得到了用户指定路径下的接口，进行动态代理。</p>
</blockquote>
</li>
<li><p>此时利用Spring 扫描得到的BeanDefinition里面的class类型还是接口类型，显然不符合Spring的定义，所以需要修改BeanDefinition，将class 属性修改为动态代理的class对象。<font color='red'>在Mybatis 中有一个非常重要的一步，就是将生成的BeanDefinition对象的AutowiredMode属性修改为byType</font></p>
<blockquote>
<p>将属性修改为byType的原因是因为Mybatis在后续进行依赖注入的时候，需要利用Spring自己的依赖注入将该类中所有的setXxxx方法都调用一边，进行属性的赋值操作。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112082057009.png" alt="image-20211208205754573"></p>
<p>在这一步之前，还会给每一个BeanDefinition设置很多属性，包括：sqlSessionFactory、sqlSessionTemplate。</p>
<p>其中生成的代理对象对应的Class 类型是<code>org.mybatis.spring.mapper.MapperFactoryBean</code></p>
</blockquote>
</li>
<li><p>然后交由Spring去将这些BeanDefinition产生出来，相当于每一个BeanDefinition都对应这一个sqlSessionFactory，</p>
</li>
<li><p>在Spring 生产这些BeanDefinition时，会调用<code>org.mybatis.spring.mapper.MapperFactoryBean#getObject</code>，该方法的具体逻辑如下：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先获取SqlSession，但是在Mybatis的实现中SqlSession并不是跟我们实现的一样使用<code>sqlSessionFactory.openSession();</code>获得的，而是直接<code>new SqlSessionTemplate(sqlSessionFactory);</code></li>
<li>然后再根据Class的类型获取代理对象的</li>
</ol>
<p><font color='red'>这里为什么不直接使用跟我们一样的呢？跟后续的线程安全有关的！！！</font></p>
</blockquote>
</li>
<li><p>在生成BeanDefinition的时候，将<code>MapperFactoryBean</code>的<code>AotuwireMode</code>设置成的byType类型，所以所有的setXxx方法都会调用。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure>

<p>该类的父类中有两个setXxx方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.externalSqlSession) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionTemplate</span><span class="params">(SqlSessionTemplate sqlSessionTemplate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sqlSession = sqlSessionTemplate;</span><br><span class="line">  <span class="keyword">this</span>.externalSqlSession = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以Spring 容器中需要存在<code>SqlSessionFactory</code>或者<code>SqlSessionTemplate</code>的Bean，不管存在哪一个Bean，最后sqlSession都会被赋值为一个<code>SqlSessionTemplate</code>类型。</p>
</blockquote>
</li>
<li><p>当执行getMapper 的时候，就是调用<code>SqlSessionTemplate</code>中的getMapper方法，生成代理对象。</p>
</li>
</ol>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112082128112.png" alt="流程图"></p>
<hr>
<p>以上是<code>compile group: &#39;org.mybatis&#39;, name: &#39;mybatis-spring&#39;, version: &#39;1.3.2&#39;</code>中的流程，在新的Mybatis 做了些许修改。</p>
<p><code>compile group: &#39;org.mybatis&#39;, name: &#39;mybatis-spring&#39;, version: &#39;2.0.6&#39;</code>中不同的流程</p>
<ol>
<li>在2.0.6中，通过@MapperScan中使用@Improt注解导入了<code>MapperScannerRegistrar.class</code>，该类实现了<code>ImportBeanDefinitionRegistrar</code>，所以在Spring扫描到该类时，会执行<code>org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions(org.springframework.core.type.AnnotationMetadata, org.springframework.beans.factory.support.BeanDefinitionRegistry)</code>方法。</li>
<li>在上述方法中，mybatis有注册了一个<code>MapperScannerConfigurer</code>类，该类实现了<code>BeanDefinitionRegistryPostProcessor</code>，所以Spring在后续会调用<code>org.mybatis.spring.mapper.MapperScannerConfigurer#postProcessBeanDefinitionRegistry</code>的后置处理器方法</li>
<li>在该方法中才会注册scanner，进行扫描操作。</li>
<li>后续跟老版本一样</li>
</ol>
<p>这样做的好处有哪些呢？</p>
<p>​    其实可以看出，就是多了一个Bean而已，所以用于也可以自己在不使用@MapperScan注解的情况写往容器中注入该Bean 也可以实现mybatis的扫描操作。更加的灵活了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapperScannerConfigurer <span class="title">mapperScannerConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MapperScannerConfigurer mapperScannerConfigurer = <span class="keyword">new</span> MapperScannerConfigurer();</span><br><span class="line">	mapperScannerConfigurer.setBasePackage(<span class="string">&quot;com.assumejson.mapper&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mapperScannerConfigurer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么Mybatis不是使用的sqlSessionFactory-openSession-，而是直接赋值为SqlSessionTemplate"><a href="#为什么Mybatis不是使用的sqlSessionFactory-openSession-，而是直接赋值为SqlSessionTemplate" class="headerlink" title="为什么Mybatis不是使用的sqlSessionFactory.openSession()，而是直接赋值为SqlSessionTemplate"></a>为什么Mybatis不是使用的sqlSessionFactory.openSession()，而是直接赋值为SqlSessionTemplate</h2><p><strong>首先我们看mybatis在执行一条sql的时候的执行流程</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/6152cc385653bb6791db436c">一条SQL的执行流程</a></p>
<blockquote>
<p><code>org.mybatis.spring.SqlSessionTemplate#selectOne(java.lang.String)</code> –&gt;<code>this.sqlSessionProxy.&lt;T&gt; selectOne(statement)</code> –&gt; <code>DefaultSqlSession.&lt;T&gt;selectOne(statement, null);</code> </p>
<p>执行逻辑跟直接使用SqlSessionFactory后面是一样的，那么为什么要使用SqlSessionTemplate进行包装调用呢？</p>
<p>就是为了线程安全考虑的。</p>
<ol>
<li>在创建BeanDefinition的时候，每一个BeanDefinition都会有自己的SqlSessionFactory，为了保证每一个线程都有自己的DefaultSqlSession，Mybatis利用ThreadLocal技术将该<code>DefaultSqlSession</code>存储在ThreadLocal中，每次执行<code>SqlSessionTemplate#selectOne</code>时，都会判断ThreadLocal中是否存在<code>DefaultSqlSession</code>。如果不存在就会new一个新的<code>DefaultSqlSession</code>。</li>
</ol>
</blockquote>
<p>流程如下：</p>
<ol>
<li>在创建<code>SqlSessionTemplate</code>会执行</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="params"><span class="function">    PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">  notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">  <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">  <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">  <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">      SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> Class[] &#123; SqlSession.class &#125;,</span><br><span class="line">      <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 其中会生成一个代理对象会生成<code>new SqlSessionInterceptor());</code></p>
<p>该类中会调用一个<code>getSqlSession</code>方法。该方法为通过Spring的事务底层调用ThreadLocal实现线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112082210764.png" alt="image-20211208220345967"></p>
</blockquote>
<blockquote>
<p>基于这种方式，如果每次执行SQL的时候，ThreadLocal中都没有SqlSession，那么每次都会重新new一个，这样就会导致Mybatis 基于SqlSession的一级缓存失效了！！！！</p>
<p>这就是Spring整合Mybatis导致的一级缓存失效的问题。</p>
</blockquote>
<h2 id="Spring整个Mybatis-的一级缓存失效的问题。"><a href="#Spring整个Mybatis-的一级缓存失效的问题。" class="headerlink" title="Spring整个Mybatis 的一级缓存失效的问题。"></a>Spring整个Mybatis 的一级缓存失效的问题。</h2><p>​    先从解决缓存失效说起。非常简单，只需要使用Spring的事务就可以解决，@Transaction注解就可以解决了。</p>
<p>加上该注解之后，在同一个事务下的所有操作都会在同一个SqlSession中完成。</p>
<p>​    失效的原因就是Mybatis 在执行SQL是，为了保证线程的安全，必须为每一个线程生成线程独有的SqlSession。这样才能保证线程安全。</p>
<p><strong>个人理解：</strong></p>
<blockquote>
<p>​    个人认为Mybatis的一级缓存并不是失效了，而是存活的实现太短了，因为在没有开启事务的时候，SqlSession是以线程为单位的，线程在执行完之后被回收，当前SqlSession也会被关闭。所以应该不能说一级缓存失效了，而是存活的时间太短了。</p>
<p>​    并且在开发中并不推荐使用一级缓存，因为Mybatis在一级缓存和事务隔离级别的取舍情况下，显然应该悬着后者。</p>
</blockquote>
<h1 id="Spring-AOP-源码解析"><a href="#Spring-AOP-源码解析" class="headerlink" title="Spring AOP 源码解析"></a>Spring AOP 源码解析</h1><p>​    整个AOP集成了AspectJ 中。整体就是想Spring 容器中添加一个<code>AnnotationAwareAspectJAutoProxyCreator</code>的Bean，然后将AOP的拦截的参数编译成一个个advisor，在Bean初始化后，对每一个Bean 进行对比判断，查看当前Bean是否与Advisor 是否匹配，匹配则会进行AOP 代理操作。</p>
<p>​    整个代理操作都会判断Bean 是否存在接口，如果存在接口则使用JDK的动态代理，如果不是则使用CGLIB。</p>
<p>​    在JDK代理中，获取的类型只能是接口类型，并且导入的类型也必须为接口类型。不然会报错</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/books/share/5f19528d-d89b-4b69-a7bd-9f436a2dd734/gwpfs5">https://www.yuque.com/books/share/5f19528d-d89b-4b69-a7bd-9f436a2dd734/gwpfs5</a> AOP的整体逻辑</p>
<h1 id="Spring-Transaction-底层源码解析"><a href="#Spring-Transaction-底层源码解析" class="headerlink" title="Spring Transaction 底层源码解析"></a>Spring Transaction 底层源码解析</h1><p>​    在Spring AOP中，所有的AOP操作实际上到源码层面都会生成一个一个的advisor，在bean 进入到初始化后的后置处理器时，每一个Bean 都会进行意义的匹配，匹配成功则需要进行AOP动态代理。</p>
<p>​    而Spring中的事务就是纯纯的基于AOP去实现的，在开启事务时，Spring 容器会躲出一个Advisor来匹配Bean，匹配其中是否包含了@Transaction注解的方法或者类，如果存在，则进行AOP，进行事务的增强。</p>
<h2 id="EnableTransactionManagement-的工作原理"><a href="#EnableTransactionManagement-的工作原理" class="headerlink" title="@EnableTransactionManagement  的工作原理"></a>@EnableTransactionManagement  的工作原理</h2><p>​    整个Spring 事务的加载个工作流程是完完全全的AOP的实现，会根据是否存在事务进行AOP代理，然后判断在生成事务时，是否为第一次生成事务对象，并且每一个访问都会为当前访问的线程生成或者获取一个TransactionStatus对象用来标识当前事务对象的状态。用来区分事务的隔离级别是否为最新的事务线程等。</p>
<p>​    还有所有的事务对象都是存在当前的线程的ThreadLocal中的，不存在线程安全问题的。</p>
<p>​    其中如果在进行事务的传播机制时，Spring 会判断当前线程中是否存在事务对象，如果存在则挂起，并且生成一个挂起的对象，将就的事务对象设置到挂起的对象中，（在事务不传播或者创建新的事务时需要进行。）</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112152256046.png" alt="Spring事务EnableTransactionManagement源码流程"></p>
<h2 id="Spring-事务的传播机制"><a href="#Spring-事务的传播机制" class="headerlink" title="Spring 事务的传播机制"></a>Spring 事务的传播机制</h2><p>​    假设现在有两个方法，一个a(),一个b()。其中有非常多种的事务传播机制。</p>
<ol>
<li><p>调用a方法时，调用b，并且都没有制定事务的隔离级别。都为默认</p>
<ol>
<li><p>这种情况就是在调用a时，调用b，调用b时需要重新常见一个新的事务。</p>
<ul>
<li>具体步骤：<ul>
<li>首先代理对象执行a方法时，会用事务管理器新创建一个数据库连接池</li>
<li>把数据库连接池的autoCommit设置为false</li>
<li>然后将数据库连接池对象设置到当前线程的ThreadLocal中</li>
<li>执行a()中的sql</li>
<li>执行a()方法中调用b()<ul>
<li>调用b方法时也需要调用代理对象，所以调用代理对象b()时，会判断当前线程中是否存在事务对象，如果存在则表示当前线程已经存在一个事务了，所以需要挂起。</li>
<li>挂起就是将当前线程的ThreadLocal中的a事务移除，并且赋值给一个新的挂起对象。</li>
<li>然后生成b的事务对象并且设置autoCommit为false，然后将b的事务对象设置到当前线程的ThreadLocal中。</li>
<li>执行b的sql</li>
<li>如果b正常执行完毕，则将当前线程中的事务拿出来，进行提交</li>
<li>b正常提交完毕后，恢复挂起的a的事务。</li>
</ul>
</li>
<li>a()正常执行完毕，提交（恢复的a事务）当前ThreadLocal中的事务a。</li>
</ul>
</li>
</ul>
<blockquote>
<p>整个过程的核心就是判断当前线程ThreadLocal中是否存在事务对象，如果存在事务对象，则说明当前线程已经存在事务，需要将旧的事务挂起。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="Spring-事务传播机制案例分析"><a href="#Spring-事务传播机制案例分析" class="headerlink" title="Spring 事务传播机制案例分析"></a>Spring 事务传播机制案例分析</h2><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112161149529.png" alt="image-20211216114907110"></p>
<blockquote>
<p>Spring的默认传播机制是：<code>Propagation.REQUIRED</code>，在当前事务中如果没有事务，则创建一个新的事务对象，如果存在事务则沿用当前事务。</p>
<ol>
<li>执行test时，会创建一个事务对象。</li>
<li>执行test sql</li>
<li>执行a方法，会沿用当前test的事务对象</li>
<li>执行a的sql</li>
<li>提交</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112161153574.png" alt="image-20211216115302107"></p>
<blockquote>
<p>test方法会报错</p>
<p>由于test 和a 两个都是用的同一个事务对象，则两者都会回滚。</p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112161156681.png" alt="image-20211216115659288"></p>
<blockquote>
<p>跟上面的情况一样</p>
<p>两个方法公用的是同一个事务，所以两个sql都会回滚</p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112161158934.png" alt="image-20211216115806546"></p>
<blockquote>
<p>a方法的事务隔离级别是重新创建一个新的事务对象，当时在源码中可以看到，当执行一个事务的时候，如果当前事务抛出异常，在进行回滚之后，当前事务还是会将该异常抛出，所以导致挂起的事务在恢复之后还是会接受到异常，所以还是会回滚。</p>
<p>所以两个方法里面的sql还是会回滚。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112161207013.png" alt="image-20211216120709552"></p>
</blockquote>
<h2 id="如何在捕获到异常之后，进行手动回滚呢？"><a href="#如何在捕获到异常之后，进行手动回滚呢？" class="headerlink" title="如何在捕获到异常之后，进行手动回滚呢？"></a>如何在捕获到异常之后，进行手动回滚呢？</h2><p>​    有的时候，在出现异常的时候，有可能被捕获到了，如果做其他抛出处理，则这个异常会被无视掉，事务也会正常的提交，所以Spring 的事务对象是支持手动执行回滚的。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112161214551.png" alt="image-20211216121430148"></p>
<h2 id="TransactionSynchronization-提供事务的可塑性"><a href="#TransactionSynchronization-提供事务的可塑性" class="headerlink" title="TransactionSynchronization 提供事务的可塑性"></a>TransactionSynchronization 提供事务的可塑性</h2><p>​    程序员可以自定义事务的状态监听</p>
<p>利用TransactionSynchronization</p>
<h2 id="Spring-事务的失效场景"><a href="#Spring-事务的失效场景" class="headerlink" title="Spring 事务的失效场景"></a>Spring 事务的失效场景</h2><h3 id="访问权限问题"><a href="#访问权限问题" class="headerlink" title="访问权限问题"></a>访问权限问题</h3><p>​    在事务传播中，如果方法时private的，则事务不能进行事务传播，因为在进行动态代理时，访问不到私有方法。</p>
<p>在Spring源码中，有明确的要求被事务代理的类，必须是public的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Don&#x27;t allow no-public methods as required. 被事务代理的类，必须是public的</span></span><br><span class="line">   <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The method may be on an interface, but we need attributes from the target class.</span></span><br><span class="line">   <span class="comment">// If the target class is null, the method will be unchanged.</span></span><br><span class="line">   Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First try is the method in the target class.</span></span><br><span class="line">   <span class="comment">// 先检查方法上是否存在@Transactional</span></span><br><span class="line">   TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> txAttr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Second try is the transaction attribute on the target class.</span></span><br><span class="line">   <span class="comment">// 再检查类</span></span><br><span class="line">   txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">      <span class="keyword">return</span> txAttr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">      <span class="comment">// Fallback is to look at the original method.</span></span><br><span class="line">      txAttr = findTransactionAttribute(method);</span><br><span class="line">      <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> txAttr;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Last fallback is the class of the original method.</span></span><br><span class="line">      txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">         <span class="keyword">return</span> txAttr;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如果一个方法被final或者static-修饰时，事务失效"><a href="#如果一个方法被final或者static-修饰时，事务失效" class="headerlink" title="如果一个方法被final或者static 修饰时，事务失效"></a>如果一个方法被final或者static 修饰时，事务失效</h3><p>​    如果一个类被final或者static 修饰，事务功能也会失效。</p>
<p>原因就是在spring事务的核心就是AOP动态代理，但是不论是jdk还是CGLIB，两者在生成动态代理对象时，都不能对final或者static方法进行重写。所以无法对这种方法进行动态代理</p>
<h3 id="在方法类直接调用this方法"><a href="#在方法类直接调用this方法" class="headerlink" title="在方法类直接调用this方法"></a>在方法类直接调用this方法</h3><p>​    在上面的实例中就提到多，在同一个类中调用方法，需要进行自我注入，才能够实现事务的传递，如果直接调用方法，了解动态代理应该知道，如果直接调用本地方法，实质上是this.调用的，那么该方法根本不会走代理逻辑。所以事务不会生效。</p>
<blockquote>
<p>解决办法有很多，使用自我注入，或者使用获取当前的AOP对象进行代理对象调用方法。</p>
<p>((ServiceA)AopContext.currentProxy()).doSave(user);</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://z.itpub.net/article/detail/18A4D9564A61EC7AF8EAA66FCA251444">Spring事务失效场景</a></p>
<p>总体来说，Spring事务会失效原理就是Spring事务本身是一个存在线程ThreadLocal中的一个Map，key是数据源，value是数据库连接。所以如果出现了线程不一致的情况下，那么事务不会进行传播等操作。</p>
<p>​    还有就是事务本身就是通过AOP动态代理来实现的，如果事务调用的方法代理对象访问不到，或者不会经过代理对象，也不会走事务逻辑，因为事务也不会生效。</p>
<p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p>
<ul>
<li><code>REQUIRED</code> 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li>
<li><code>SUPPORTS</code> 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li>
<li><code>MANDATORY</code> 如果当前上下文中存在事务，否则抛出异常。</li>
<li><code>REQUIRES_NEW</code> 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li>
<li><code>NOT_SUPPORTED</code> 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li>
<li><code>NEVER</code> 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li>
<li><code>NESTED</code> 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:954253184@qq.com">努力努力再努力xLg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://assumejson.github.io/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">https://assumejson.github.io/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://assumejson.github.io" target="_blank">努力努力再努力xLg</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-60e9a8d4f9258832" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013059.png" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013059.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013135.jpg" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013135.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/12/15/%E5%86%8D%E7%9C%8BDubbo-%E7%BA%AF%E6%89%8B%E5%86%99Dubbo%E3%80%81%E7%90%86%E8%A7%A3Dubbo%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"><img class="prev-cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112151623189.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">再看Dubbo-纯手写Dubbo、理解Dubbo整体架构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/11/我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程/" title="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程"><img class="cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-11</div><div class="title">我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710212139.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">努力努力再努力xLg</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AssumeJson"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AssumeJson" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:954253184@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我准备战斗到最后，并不是因为我勇敢，而是我想见证一切。</br>&nbsp;&nbsp;推荐关注我的公众号，无广不打扰。及时推送，保持与博客同步更新。一起进步，一起超神<img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711095917.jpg" /></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">IOC的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory-%E4%B8%8E-FactoryBean-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">BeanFactory 与 FactoryBean 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8FactoryBean%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">在什么场景下使用FactoryBean？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FactoryBean-%E7%94%9F%E6%88%90%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%BD%BF%E7%94%A8-Bean%E7%94%9F%E6%88%90%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">FactoryBean 生成的自定义对象与使用@Bean生成的对象有什么区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean-%E5%9C%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%BC%BA%E8%A1%8C%E7%BB%88%E6%AD%A2%E5%98%9B%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">Bean 在创建的过程中可以强行终止嘛？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">具体怎么操作的呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext-%E4%B8%8E-BeanFactory%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">ApplicationContext 与 BeanFactory的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BE%80Spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">如何往Spring容器中设置环境变量？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%80%8E%E4%B9%88%E5%9C%A8Bean-%E5%88%9B%E5%BB%BA%E4%B9%8B%E5%89%8D%E7%BB%99%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">Spring怎么在Bean 创建之前给自定义的赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.</span> <span class="toc-text">Spring bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.</span> <span class="toc-text">Bean的创建生命周期简单介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CBean%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%EF%BC%8CSpring%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">如果Bean中存在多个构造，Spring该如何处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%A4%9A%E4%B8%AA-Bean%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%86%E6%98%AF%E6%96%B9%E6%B3%95%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8CSpring%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BEBean%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text">如果一个对象有多个@Bean注解，但是方法名不一样，Spring会如何寻找Bean对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E5%88%9B%E5%BB%BABean%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">如果在创建Bean的时候，有参构造是一个对象怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AABean%E5%AF%B9%E8%B1%A1%E5%90%8C%E6%97%B6%E8%A2%AB-Bean%E5%92%8C-Component%E4%BF%AE%E9%A5%B0%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">如果一个Bean对象同时被@Bean和@Component修饰，会出现两个对象吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%80%BC%E5%90%97%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">AOP中生成的代理对象里面的属性对象有值吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%BAnull%EF%BC%8C%E9%82%A3%E4%B9%88Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%88%B0%E8%AF%A5%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E5%88%B6%E5%AE%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">Spring的代理对象中的属性为null，那么Spring是如何调用到该对象执行制定方法的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E4%B8%8B%E4%BA%8B%E5%8A%A1%E4%B8%8D%E8%83%BD%E4%BC%A0%E6%92%AD%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">13.</span> <span class="toc-text">AOP下事务不能传播的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinition%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%B8%8EBean%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">BeanDefinition的定义，与Bean的几种定义方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-number">15.</span> <span class="toc-text">Spring 中的类型转换的运用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number"></span> <span class="toc-text">Spring Bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90BeanDefinition"><span class="toc-number">1.</span> <span class="toc-text">生成BeanDefinition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean-%E7%94%9F%E6%88%90%E4%B9%8B%E5%89%8D%E7%9A%84%E6%89%AB%E6%8F%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">Spring Bean 生成之前的扫描操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinition%E5%9C%A8%E7%94%9F%E6%88%90%E6%97%B6%EF%BC%8C%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">BeanDefinition在生成时，判断类的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinition%E5%9C%A8%E7%94%9F%E6%88%90%E6%97%B6%EF%BC%8CScannedGenericBeanDefinition%E7%9A%84beanClass%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B8%BAObject%E7%9A%84%E5%A6%99%E7%94%A8%E3%80%82"><span class="toc-number">2.2.</span> <span class="toc-text">BeanDefinition在生成时，ScannedGenericBeanDefinition的beanClass属性定为Object的妙用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E8%AE%BE%E7%BD%AEBeanName%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A6%82%E6%9E%9CBean%E7%9A%84%E5%90%8D%E7%A7%B0%E6%98%AFABtest%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5bean%E7%9A%84%E5%90%8D%E5%AD%97%E9%BB%98%E8%AE%A4%E4%BC%9A%E7%94%9F%E6%88%90%E5%95%A5%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">Spring设置BeanName的操作，如果Bean的名称是ABtest，那么该bean的名字默认会生成啥？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6BeanDefinition%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%8C%E8%A7%A3%E5%86%B3bean%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%88%B6%E4%BA%B2%E5%B1%9E%E6%80%A7%E7%9A%84%E8%A6%86%E7%9B%96%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">合并BeanDefinition（非常重要，解决bean之间的父子关系，实现父亲属性的覆盖）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E5%9C%A8Bean-%E5%90%88%E5%B9%B6%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AE%9E%E9%99%85%E7%94%9F%E6%88%90%E4%BA%86%E5%A4%9A%E5%B0%91Bean%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">Spring在Bean 合并之后，实际生成了多少Bean对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%ADBeanFactory-%E4%B8%8EFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">判断BeanFactory 与FactoryBean的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CFactoryBean%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E4%BA%86SmartFactoryBean"><span class="toc-number">3.2.1.</span> <span class="toc-text">如果FactoryBean同时实现了SmartFactoryBean</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E5%9C%A8%E5%88%9B%E5%BB%BABean-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BC%9A%E8%80%83%E8%99%91%E5%88%B0Spring-%E6%98%AF%E5%90%A6%E4%BC%9A%E6%9C%89%E7%88%B6%E5%B7%A5%E5%8E%82"><span class="toc-number">3.3.</span> <span class="toc-text">Spring在创建Bean 的时候，会考虑到Spring 是否会有父工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-getBean%E6%98%AF%E5%B8%A6-amp-%E4%B8%8E%E4%B8%8D%E5%B8%A6%EF%BC%8CSpring%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">Spring getBean是带&amp;与不带，Spring内部的处理逻辑？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FactoryBean-%E4%B8%AD%E4%BC%9A%E7%94%9F%E6%88%90%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">FactoryBean 中会生成几个对象，生成对象的时机是什么时候？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8A%E5%B0%B1%E6%98%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B9%8B%E5%89%8D%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number"></span> <span class="toc-text">以上就是实例化之前的操作。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B9%8B%E5%89%8D%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">实例化之前的加载类的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B9%8B%E5%89%8D%EF%BC%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8Bean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">Bean的实例化之前（第一次调用Bean的后置处理器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean-%E5%90%88%E5%B9%B6%E5%90%8E%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">Spring Bean  合并后的后置处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%8E%EF%BC%8C%E8%B0%83%E7%94%A8instanceBeanPostProcessor%E4%B8%AD%E7%9A%84postProcessAfterInstantiation"><span class="toc-number">3.</span> <span class="toc-text">实例化后，调用instanceBeanPostProcessor中的postProcessAfterInstantiation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%89%8D%E5%90%8E%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">为什么实例化前后传入的参数不同？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">属性赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E7%9A%84%E8%87%AA%E6%88%91%E6%B3%A8%E5%85%A5byType%E3%80%81byName"><span class="toc-number">4.1.</span> <span class="toc-text">Spring的自我注入byType、byName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#byName%E3%80%81byType-%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">4.2.</span> <span class="toc-text">byName、byType 的实现逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Spring%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%8C%E8%BF%98%E8%A6%81%E5%8A%A0%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%91%A2"><span class="toc-number">4.3.</span> <span class="toc-text">为什么Spring已经有了自己的依赖注入，还要加入注解方式呢?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%EF%BC%8C%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">初始化前，属性赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aware-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">Aware 的执行场景是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext%E4%B8%AD%E5%A2%9E%E5%BC%BA%E7%9A%84Aware%E5%B1%9E%E6%80%A7%E5%9C%A8%E5%93%AA%E9%87%8C%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">ApplicationContext中增强的Aware属性在哪里加载？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PostConstructor%E5%92%8C-PreDestroy%E6%B3%A8%E8%A7%A3%E5%9C%A8%E9%82%A3%E9%87%8C%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">@PostConstructor和@PreDestroy注解在那里加载？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E4%BC%9A%E6%9C%89%E9%82%A3%E4%BA%9B%E6%93%8D%E4%BD%9C"><span class="toc-number">9.</span> <span class="toc-text">初始化时会有那些操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E"><span class="toc-number">10.</span> <span class="toc-text">初始化后</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean-%E9%94%80%E6%AF%81"><span class="toc-number"></span> <span class="toc-text">Bean 销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E5%AE%B9%E5%99%A8%E9%94%80%E6%AF%81%E7%9A%84%E6%B5%81%E7%A8%8B-TODO"><span class="toc-number">1.</span> <span class="toc-text">Spring 容器销毁的流程 TODO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E7%BB%93-TODO"><span class="toc-number"></span> <span class="toc-text">Spring Bean的生命周期总结 TODO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">Spring依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E8%87%AA%E5%B8%A6%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5byName%E3%80%81byType"><span class="toc-number">1.</span> <span class="toc-text">Spring自带的依赖注入byName、byType</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#byName%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">1.1.</span> <span class="toc-text">byName底层实现逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-%E5%9C%A8%E8%8E%B7%E5%8F%96Bean%E7%9A%84set%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAname-class-%E7%9A%84%E5%B1%9E%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">Spring 在获取Bean的set方法时，为什么会返回一个name &#x3D; class 的属性呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#byType"><span class="toc-number">1.2.</span> <span class="toc-text">byType</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autowire-%E6%B3%A8%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">Autowire 注解依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%B3%A8%E5%85%A5%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">寻找注入点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">属性注入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowire%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95resolveDependency"><span class="toc-number">2.2.</span> <span class="toc-text">@Autowire中的核心方法resolveDependency</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#resolveDependency-%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">resolveDependency 核心解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Lazy"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">@Lazy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95doResolveDependency"><span class="toc-number">2.3.</span> <span class="toc-text">真正的解析依赖的方法doResolveDependency</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Value"><span class="toc-number">2.3.1.</span> <span class="toc-text">@Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-Primary%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.3.2.</span> <span class="toc-text">解析@Primary注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-Priority%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.3.3.</span> <span class="toc-text">解析@Priority注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%9F%A5%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84Bean%E7%9A%84%EF%BC%9FfindAutowireCandidates-beanName-type-descriptor"><span class="toc-number">3.</span> <span class="toc-text">Spring 到底是怎么通过类型查找到所有的Bean的？findAutowireCandidates(beanName, type, descriptor)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%B3%A8%E5%85%A5%E7%9A%84bean%E6%98%AF%E5%90%A6%E6%98%AF%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%85%A5%E8%87%AA%E5%B7%B1"><span class="toc-number">3.0.1.</span> <span class="toc-text">判断当前注入的bean是否是自己注入自己</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E7%9A%84Bean-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">3.0.2.</span> <span class="toc-text">判断当前的Bean 是否支持自动依赖注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD-Qualifer-%E5%86%B3%E5%AE%9AbeanName%E5%85%B7%E4%BD%93%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.0.3.</span> <span class="toc-text">判断@Qualifer 决定beanName具体对应的实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">@Resource注解解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number"></span> <span class="toc-text">循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AD%E7%8E%AF%EF%BC%8C%E5%8A%A0%E5%85%A5%E7%BC%93%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">打破循环依赖的闭环，加入缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%97%B6%EF%BC%8C%E8%BF%9B%E8%A1%8CAOP%E6%8F%90%E5%89%8D%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">在实例化时，进行AOP提前生成代理对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%97%B6%EF%BC%8C%E5%B0%86AOP%E6%8F%90%E5%89%8D%E5%88%B0%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%AD%E8%BF%9B%E8%A1%8C"><span class="toc-number">3.</span> <span class="toc-text">在出现循环依赖时，将AOP提前到实例化中进行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%A4%E6%96%ADBean-%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%91%A2%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">Spring在什么时候判断Bean 是否出现了循环依赖呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%EF%BC%8CAOP%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E9%87%8D%E5%A4%8D%E5%88%9B%E5%BB%BA%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">引入二级缓存解决，AOP代理对象重复创建的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%9F%E9%9C%80%E8%A6%81%E5%B0%86%E5%8E%9F%E5%A7%8B%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%85%A5"><span class="toc-number">4.2.</span> <span class="toc-text">二级缓存也需要将原始对象存入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0AOP%E8%87%AA%E6%88%91%E5%88%A4%E6%96%AD"><span class="toc-number">5.</span> <span class="toc-text">引入三级缓存实现AOP自我判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E5%91%A2%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">为什么要引入第三级缓存呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%83%BD%E6%98%AF%E5%8E%9F%E5%9E%8BBean%EF%BC%8CSpring%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%98%9B%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">循环依赖都是原型Bean，Spring可以解决嘛？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%AD%E4%B8%A4%E4%B8%AA%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%98%AF%E5%8D%95%E4%BE%8BBean%EF%BC%8CSpring%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%98%9B%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">循环依赖中两个中有一个是单例Bean，Spring可以解决嘛？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%AD%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%8CSpring%E8%83%BD%E5%A4%9F%E8%A7%A3%E5%86%B3%E5%98%9B%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">循环依赖中，构造方法循环依赖，Spring能够解决嘛？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transaction%E5%92%8C-Aysnc-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">@Transaction和@Aysnc 注解的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%85%A5%E8%87%AA%E5%B7%B1%E7%AE%97%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%98%9B%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">自己注入自己算是循环依赖嘛？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%8C%E5%9C%A8%E6%98%AF%E4%B8%AA9%E5%B9%B4%E7%94%A8%E4%BA%8E%E8%BF%8E%E6%9D%A5%E6%9B%B4%E6%96%B0%EF%BC%8C%E9%83%BD%E6%9B%B4%E6%96%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E5%86%85%E5%AE%B9%E5%91%A2%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">循环依赖的核心逻辑，在是个9年用于迎来更新，都更新了那些内容呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E7%9A%84%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0"><span class="toc-number"></span> <span class="toc-text">Spring 的推断构造</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">Spring 的启动源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Spring%E5%90%AF%E5%8A%A8%E6%97%B6%EF%BC%8C%E5%88%A4%E6%96%AD%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">0.1.</span> <span class="toc-text">问题：如何在Spring启动时，判断容器中的环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E9%80%9A%E8%BF%87%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%83%BD%E5%90%A6%E9%87%8D%E5%A4%8D%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">0.2.</span> <span class="toc-text">Spring通过模板方法实现了对容器的不同实现，能否重复刷新的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">Spring 解析配置流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88MyBatis-%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">Spring整合MyBatis 底层源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99MyBatis%E6%95%B4%E5%90%88%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">手写MyBatis整合流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%B0%86Mapper-%E6%B3%A8%E5%86%8C%E5%88%B0BeanDefinitionMap%E4%B8%AD%E5%8E%BB"><span class="toc-number">1.1.</span> <span class="toc-text">尝试将Mapper 注册到BeanDefinitionMap中去</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8FactoryBean-%E8%BF%9B%E8%A1%8C%E5%8C%85%E8%A3%85Mapper%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">使用FactoryBean 进行包装Mapper接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8FactoryBean%E7%9A%84%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%EF%BC%8C%E5%8A%A8%E6%80%81%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">使用FactoryBean的构造参数，动态定义代理对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8BeanDefinitionRegistryPostProcessor-%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%86%8CBeanDefinition"><span class="toc-number">1.4.</span> <span class="toc-text">使用BeanDefinitionRegistryPostProcessor 进行注册BeanDefinition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%89%AB%E6%8F%8F%E8%BF%9B%E8%A1%8CMapper-%E7%9A%84%E6%89%AB%E6%8F%8F%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%A2%9E%E5%88%A0Mapper-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.</span> <span class="toc-text">使用扫描进行Mapper 的扫描实现动态增删Mapper 代理对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99Spring%E7%9A%84%E6%89%AB%E6%8F%8F%E5%99%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%8F%AA%E6%89%AB%E6%8F%8F%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">重写Spring的扫描器，实现只扫描接口类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99Spring%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.7.</span> <span class="toc-text">重写Spring扫描的过滤条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99Spring-doscan%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9A%E5%88%B6BeanDefinition"><span class="toc-number">1.8.</span> <span class="toc-text">重写Spring doscan方法，定制BeanDefinition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5Mybatis-Factory-%E8%BF%9B%E8%A1%8CMapper-%E4%BB%A3%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">注入Mybatis Factory 进行Mapper 代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E6%95%B4%E5%90%88MyBatis-%E7%9A%84%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Spring 整合MyBatis 的源码流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Mybatis%E4%B8%8D%E6%98%AF%E4%BD%BF%E7%94%A8%E7%9A%84sqlSessionFactory-openSession-%EF%BC%8C%E8%80%8C%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E4%B8%BASqlSessionTemplate"><span class="toc-number">3.</span> <span class="toc-text">为什么Mybatis不是使用的sqlSessionFactory.openSession()，而是直接赋值为SqlSessionTemplate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%95%B4%E4%B8%AAMybatis-%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">Spring整个Mybatis 的一级缓存失效的问题。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-AOP-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">Spring AOP 源码解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Transaction-%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">Spring Transaction 底层源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EnableTransactionManagement-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">@EnableTransactionManagement  的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">Spring 事务的传播机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">Spring 事务传播机制案例分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8D%95%E8%8E%B7%E5%88%B0%E5%BC%82%E5%B8%B8%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%89%8B%E5%8A%A8%E5%9B%9E%E6%BB%9A%E5%91%A2%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">如何在捕获到异常之后，进行手动回滚呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TransactionSynchronization-%E6%8F%90%E4%BE%9B%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8F%AF%E5%A1%91%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">TransactionSynchronization 提供事务的可塑性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">6.</span> <span class="toc-text">Spring 事务的失效场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">访问权限问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%A2%ABfinal%E6%88%96%E8%80%85static-%E4%BF%AE%E9%A5%B0%E6%97%B6%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">6.2.</span> <span class="toc-text">如果一个方法被final或者static 修饰时，事务失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%96%B9%E6%B3%95%E7%B1%BB%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8this%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">在方法类直接调用this方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring面试题总结-结合Spring源码解析"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring面试题总结-结合Spring源码解析"/></a><div class="content"><a class="title" href="/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring面试题总结-结合Spring源码解析">Spring面试题总结-结合Spring源码解析</a><time datetime="2021-12-16T04:41:35.000Z" title="发表于 2021-12-16 12:41:35">2021-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/15/%E5%86%8D%E7%9C%8BDubbo-%E7%BA%AF%E6%89%8B%E5%86%99Dubbo%E3%80%81%E7%90%86%E8%A7%A3Dubbo%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" title="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112151623189.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构"/></a><div class="content"><a class="title" href="/2021/12/15/%E5%86%8D%E7%9C%8BDubbo-%E7%BA%AF%E6%89%8B%E5%86%99Dubbo%E3%80%81%E7%90%86%E8%A7%A3Dubbo%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" title="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构">再看Dubbo-纯手写Dubbo、理解Dubbo整体架构</a><time datetime="2021-12-15T08:15:13.000Z" title="发表于 2021-12-15 16:15:13">2021-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/11/%E6%88%91%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BD%AE%E5%AD%90%EF%BC%8Cclever-spring%EF%BC%8C%E5%B8%AE%E5%8A%A9%E6%82%A8%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3Spring%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" title="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程"/></a><div class="content"><a class="title" href="/2021/12/11/%E6%88%91%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BD%AE%E5%AD%90%EF%BC%8Cclever-spring%EF%BC%8C%E5%B8%AE%E5%8A%A9%E6%82%A8%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3Spring%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" title="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程">我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程</a><time datetime="2021-12-10T18:00:02.000Z" title="发表于 2021-12-11 02:00:02">2021-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/" title="HDFS的读写数据流程详解与节点距离的计算分析"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191150455.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HDFS的读写数据流程详解与节点距离的计算分析"/></a><div class="content"><a class="title" href="/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/" title="HDFS的读写数据流程详解与节点距离的计算分析">HDFS的读写数据流程详解与节点距离的计算分析</a><time datetime="2021-09-19T04:19:47.000Z" title="发表于 2021-09-19 12:19:47">2021-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/12/MySQL%EF%BC%88InnoDB%EF%BC%89-%E8%A7%A3%E9%94%81%E4%BC%98%E5%8C%96-semi-consitent-read-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" title="MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210712113024.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析"/></a><div class="content"><a class="title" href="/2021/07/12/MySQL%EF%BC%88InnoDB%EF%BC%89-%E8%A7%A3%E9%94%81%E4%BC%98%E5%8C%96-semi-consitent-read-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" title="MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析">MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析</a><time datetime="2021-07-12T03:27:05.000Z" title="发表于 2021-07-12 11:27:05">2021-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 努力努力再努力xLg</div><div class="footer_custom_text">Hi, welcome to my <a href="https://assumejson.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '9AMDI214RvL33G4AGFf7UWeM-gzGzoHsz',
      appKey: 'alFvEcPpeVWr0nyL36RrYHbY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="6852130449" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-DDLT48PGF4', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>