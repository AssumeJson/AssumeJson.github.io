<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HDFS的读写数据流程详解与节点距离的计算分析 | 努力努力再努力xLg</title><meta name="keywords" content="Hadoop,HDFS"><meta name="author" content="努力努力再努力xLg,954253184@qq.com"><meta name="copyright" content="努力努力再努力xLg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 1、HDFS写数据整体流程  Hadoop 集群天生支持分布式的，在创建集群时，1号节点就已经设置为NameNode节点用来操作集群的。   在HDFS client 与集群创建好连接之后（这里以Java的API为例。），首先HDFS Client 为连接到分布式文件系统中，也就是NameNode暴露出来的连接端口。   以上就是获取到分布式文件系统连接。    该行代码包含了下述所有">
<meta property="og:type" content="article">
<meta property="og:title" content="HDFS的读写数据流程详解与节点距离的计算分析">
<meta property="og:url" content="https://assumejson.github.io/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="努力努力再努力xLg">
<meta property="og:description" content="[TOC] 1、HDFS写数据整体流程  Hadoop 集群天生支持分布式的，在创建集群时，1号节点就已经设置为NameNode节点用来操作集群的。   在HDFS client 与集群创建好连接之后（这里以Java的API为例。），首先HDFS Client 为连接到分布式文件系统中，也就是NameNode暴露出来的连接端口。   以上就是获取到分布式文件系统连接。    该行代码包含了下述所有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191150455.png">
<meta property="article:published_time" content="2021-09-19T04:19:47.000Z">
<meta property="article:modified_time" content="2021-12-16T04:41:06.007Z">
<meta property="article:author" content="努力努力再努力xLg">
<meta property="article:tag" content="Hadoop">
<meta property="article:tag" content="HDFS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191150455.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://assumejson.github.io/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1db2391382f6b742f88f4d4bacf084e1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-DDLT48PGF4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DDLT48PGF4');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"9U77PNXQGB","apiKey":"c7a45d15e80ae02575c385328d379977","indexName":"dev_blog_search","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 努力努力再努力xLg","link":"链接: ","source":"来源: 努力努力再努力xLg","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HDFS的读写数据流程详解与节点距离的计算分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-16 12:41:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710212139.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191150455.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">努力努力再努力xLg</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HDFS的读写数据流程详解与节点距离的计算分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-19T04:19:47.000Z" title="发表于 2021-09-19 12:19:47">2021-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-16T04:41:06.007Z" title="更新于 2021-12-16 12:41:06">2021-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/">Develop</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/Hadoop/">Hadoop</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>7分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HDFS的读写数据流程详解与节点距离的计算分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h2 id="1、HDFS写数据整体流程"><a href="#1、HDFS写数据整体流程" class="headerlink" title="1、HDFS写数据整体流程"></a>1、HDFS写数据整体流程</h2><p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109190025890.png" alt="HDFS的写数据流程"></p>
<blockquote>
<p>Hadoop 集群天生支持分布式的，在创建集群时，1号节点就已经设置为NameNode节点用来操作集群的。</p>
</blockquote>
<ol>
<li><p>在HDFS client 与集群创建好连接之后（这里以Java的API为例。），首先HDFS Client 为连接到分布式文件系统中，也就是NameNode暴露出来的连接端口。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109190033097.png" alt="image-20210919003308353"></p>
<blockquote>
<p>以上就是获取到分布式文件系统连接。</p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109190035311.png" alt="image-20210919003532155"></p>
<blockquote>
<p>该行代码包含了下述所有的操作</p>
</blockquote>
</li>
<li><p>NameNode 接受到请求上传的请求后，会判断请求中父节点是否存在，检查权限，如果都没问题会返回给client确认应答</p>
</li>
<li><p>Client 收到上传通过应答之后，会向NameNode请求一个Block（默认大小为128M），并且返回对应的NodeData</p>
</li>
<li><p>此时的NameNode 会做比较复杂的判断包括如下几点</p>
<ol>
<li>对现有的集群做负载均衡处理</li>
<li>判断计算并且返回最近的节点（这里设计到了就近的节点距离计算的逻辑）</li>
<li>返回的节点会包含自身，就近的机架等信息</li>
</ol>
</li>
<li><p>收到传输对应的NodeData之后，Client 会创建输出流<code>FSDataOutputStream</code>进行数据传输</p>
<ol>
<li><p>这里的数据传输与zk中的数据交互非常类似，都是将数据拆分为多个packet数据包，进行分片传输。</p>
<p>一个packet的组成是由多个<code>chunk</code>和4个byte字节组成的，也就是多个chunk（512byte）+ chunksum（4byte）组成的，当这些个chunk装满了一个packet（64kb）时，才会传送到DataNode中。</p>
</li>
<li><p>所有的packet会先存放到一个缓冲队列中，当一个packet发送到DataNode中时，还会在应答队列中缓存一份该packet，当该packet应答成功之后，应答队列中的缓冲会删除，如果没有成功，应答队列中的packet会重新发送给DataNode，以此类推。直到所有的数据都传送完毕，（有点类似于RocketMQ中的ack模式）</p>
</li>
<li><p>客户端请求dn1上传数据时，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通道管道建立完成</p>
<ol>
<li>dn1，dn2，dn3逐级应答客户端。</li>
<li>客户端这时才会给dn1上传第一个Block（先从磁盘中读取数据，将数据存放到本地内存中，为了提到效率），然后再讲数据以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1 <font color='red'>每传一个Packet就会放入一个到应答队列中等待应答</font></li>
</ol>
</li>
</ol>
</li>
<li><p>当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器（并且会重复执行3-5步）</p>
</li>
</ol>
<h2 id="2、网络拓扑-节点距离计算"><a href="#2、网络拓扑-节点距离计算" class="headerlink" title="2、网络拓扑-节点距离计算"></a>2、网络拓扑-节点距离计算</h2><p>​    在HDFS写数据的过程中，NameNode会选择距离待上传最近距离的DateNode接受数据，该距离是如何计算的呢？</p>
<p>​    <font color ="red">节点距离：两个节点到大最近的共同祖先的距离总和</font></p>
<blockquote>
<p>首先理解一下机架的原理</p>
<p>​    机架相当于一个机房里面放着很多个架子，这些架子都整齐的码放着服务器</p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109190952040.png" alt="image-20210919095223334"></p>
<blockquote>
<p>上图中</p>
<p>数据中心就是相当于一个机房</p>
<p>节点就相当于机房中的存放机架一排一排的编号</p>
<p>机架就是具体到那个编号的柜子</p>
</blockquote>
<p>假设两个分片在同一个节点上，那么两个节点的共同祖先就是当前节点，不用想钱追溯。其他情况都一次类推，最终目的就是找到相同节点。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109190958828.png" alt="image-20210919095809591"></p>
<blockquote>
<p>上图：假设 10 与5两个节点之间需要走一步是一样的道理</p>
<p>10 -&gt; 5 需要走3步</p>
</blockquote>
<h3 id="2-1、机架感知（副本存储节点的选择）"><a href="#2-1、机架感知（副本存储节点的选择）" class="headerlink" title="2.1、机架感知（副本存储节点的选择）"></a>2.1、机架感知（副本存储节点的选择）</h3><p>​    <a target="_blank" rel="noopener" href="http://hadoop.apache.org/docs/r3.1.3/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#Data_Replication">http://hadoop.apache.org/docs/r3.1.3/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#Data_Replication</a>  </p>
<blockquote>
<p>The NameNode determines the rack id each DataNode belongs to via the process outlined in <a target="_blank" rel="noopener" href="http://hadoop.apache.org/docs/r3.1.3/hadoop-project-dist/hadoop-common/RackAwareness.html">Hadoop Rack Awareness</a>. A simple but non-optimal policy is to place replicas on unique racks. This prevents losing data when an entire rack fails and allows use of bandwidth from multiple racks when reading data. This policy evenly distributes replicas in the cluster which makes it easy to balance load on component failure. However, this policy increases the cost of writes because a write needs to transfer blocks to multiple racks.</p>
<p>For the common case, when the replication factor is three, <font color="red">HDFS’s placement policy is to put one replica on the local machine if the writer is on a datanode</font>, otherwise on a random datanode, <font color="red">another replica on a node in a different (remote) rack, and the last on a different node in the same remote rack. </font>This policy cuts the inter-rack write traffic which generally improves write performance. The chance of rack failure is far less than that of node failure; this policy does not impact data reliability and availability guarantees. However, it does reduce the aggregate network bandwidth used when reading data since a block is placed in only two unique racks rather than three. With this policy, the replicas of a file do not evenly distribute across the racks. One third of replicas are on one node, two thirds of replicas are on one rack, and the other third are evenly distributed across the remaining racks. This policy improves write performance without compromising data reliability or read performance.</p>
</blockquote>
<p>​    从官方文档中可以知晓，在HDFS存储数据节点时，同时兼顾着性能和高可用的考虑，假设目前有三个节点，第一个节点Hadoop会选择存储在NameNode的本地节点，效率最高，而第二个会考虑到高可用的情况，会存储到最近的另一个节点上，但是第三个又会存储在第二个本地的节点上。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191006622.png" alt="image-20210919100648379"></p>
<h3 id="2-2、源码"><a href="#2-2、源码" class="headerlink" title="2.2、源码"></a>2.2、源码</h3><p>​    <code>BlockPlacementPolicyDefault  </code>中的<code>chooseTargetInOrder  </code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Node <span class="title">chooseTargetInOrder</span><span class="params">(<span class="keyword">int</span> numOfReplicas, Node writer, Set&lt;Node&gt; excludedNodes, <span class="keyword">long</span> blocksize, <span class="keyword">int</span> maxNodesPerRack, List&lt;DatanodeStorageInfo&gt; results, <span class="keyword">boolean</span> avoidStaleNodes, <span class="keyword">boolean</span> newBlock, EnumMap&lt;StorageType, Integer&gt; storageTypes)</span> <span class="keyword">throws</span> NotEnoughReplicasException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numOfResults = results.size();</span><br><span class="line">    <span class="keyword">if</span> (numOfResults == <span class="number">0</span>) &#123; <span class="comment">// 当节点数为0时，使用的是chooseLocalStorage 选择本地节点存储</span></span><br><span class="line">        DatanodeStorageInfo storageInfo = <span class="keyword">this</span>.chooseLocalStorage((Node)writer, excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes, <span class="keyword">true</span>);</span><br><span class="line">        writer = storageInfo != <span class="keyword">null</span> ? storageInfo.getDatanodeDescriptor() : <span class="keyword">null</span>;</span><br><span class="line">        --numOfReplicas;</span><br><span class="line">        <span class="keyword">if</span> (numOfReplicas == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Node)writer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DatanodeDescriptor dn0 = ((DatanodeStorageInfo)results.get(<span class="number">0</span>)).getDatanodeDescriptor();</span><br><span class="line">    <span class="keyword">if</span> (numOfResults &lt;= <span class="number">1</span>) &#123; <span class="comment">// 第二个节点 使用的chooseRemoteRack 选择远程节点</span></span><br><span class="line">        <span class="keyword">this</span>.chooseRemoteRack(<span class="number">1</span>, dn0, excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);</span><br><span class="line">        --numOfReplicas;</span><br><span class="line">        <span class="keyword">if</span> (numOfReplicas == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Node)writer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numOfResults &lt;= <span class="number">2</span>) &#123; <span class="comment">// 第三个时，一般情况会判断第二个if ，则落地到当前dn1节点上</span></span><br><span class="line">        DatanodeDescriptor dn1 = ((DatanodeStorageInfo)results.get(<span class="number">1</span>)).getDatanodeDescriptor();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.clusterMap.isOnSameRack(dn0, dn1)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.chooseRemoteRack(<span class="number">1</span>, dn0, excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newBlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.chooseLocalRack(dn1, excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.chooseLocalRack((Node)writer, excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --numOfReplicas;</span><br><span class="line">        <span class="keyword">if</span> (numOfReplicas == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Node)writer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.chooseRandom(numOfReplicas, <span class="string">&quot;&quot;</span>, excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);</span><br><span class="line">    <span class="keyword">return</span> (Node)writer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从源码的角度也可以很好的 看到hadoop 机架的感知逻辑</p>
</blockquote>
<h2 id="3、HDFS读数据的流程"><a href="#3、HDFS读数据的流程" class="headerlink" title="3、HDFS读数据的流程"></a>3、HDFS读数据的流程</h2><p>​    <img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191134948.png" alt="HDFS读数据流程"></p>
<ol>
<li>客户端通过 DistributedFileSystem 向 NameNode 请求下载文件， NameNode 通过查<br>询元数据，找到文件块所在的 DataNode 地址。</li>
<li>挑选一台 DataNode（就近原则，然后随机）服务器，请求读取数据。</li>
<li>DataNode 开始传输数据给客户端（从磁盘里面读取数据输入流，以 Packet 为单位<br>来做校验）。</li>
<li>客户端以 Packet 为单位接收，先在本地缓存，然后写入目标文件。  </li>
</ol>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>​    在HDFS读写过程中，可以看得出开发者竟可能能提高了存储的新能和读取数据检索速率，并且天生自带的分布式也是非常好的高可用架构，但是任然存在问题，如果存放大量零碎的小文件，HDFS的基础架构很显然是不可以做到像MySQL这种毫秒级的反应的。</p>
<p>​    在写的过程中，HDFS也兼顾了数据的安全性，在写入数据时，会先缓存一份在本地内存中，还会将数据分发到一个应答队列中，该队列等待接受应答，如果长时间没有接收到应答，该数据包也可以重新投递。类似于RabbitMQ中的ACK模式。</p>
<p>​    在读写过程中，并没有采用并发思想，使用并发去同时操作多个NodeData，原因也很简单，这样会带来数据的不稳定，HDFS使用内存队列和数据分包的形式，解决了速度问题。（也算是折中的一种方案吧）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:954253184@qq.com">努力努力再努力xLg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://assumejson.github.io/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/">https://assumejson.github.io/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://assumejson.github.io" target="_blank">努力努力再努力xLg</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Hadoop/">Hadoop</a><a class="post-meta__tags" href="/tags/HDFS/">HDFS</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-60e9a8d4f9258832" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013059.png" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013059.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013135.jpg" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013135.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/12/MySQL%EF%BC%88InnoDB%EF%BC%89-%E8%A7%A3%E9%94%81%E4%BC%98%E5%8C%96-semi-consitent-read-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"><img class="prev-cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210712113024.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/11/%E6%88%91%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BD%AE%E5%AD%90%EF%BC%8Cclever-spring%EF%BC%8C%E5%B8%AE%E5%8A%A9%E6%82%A8%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3Spring%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/"><img class="next-cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710212139.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">努力努力再努力xLg</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AssumeJson"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AssumeJson" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:954253184@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我准备战斗到最后，并不是因为我勇敢，而是我想见证一切。</br>&nbsp;&nbsp;推荐关注我的公众号，无广不打扰。及时推送，保持与博客同步更新。一起进步，一起超神<img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711095917.jpg" /></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81HDFS%E5%86%99%E6%95%B0%E6%8D%AE%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">1、HDFS写数据整体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91-%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">2、网络拓扑-节点距离计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E6%9C%BA%E6%9E%B6%E6%84%9F%E7%9F%A5%EF%BC%88%E5%89%AF%E6%9C%AC%E5%AD%98%E5%82%A8%E8%8A%82%E7%82%B9%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、机架感知（副本存储节点的选择）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E6%BA%90%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81HDFS%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3、HDFS读数据的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">4、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring面试题总结-结合Spring源码解析"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring面试题总结-结合Spring源码解析"/></a><div class="content"><a class="title" href="/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring面试题总结-结合Spring源码解析">Spring面试题总结-结合Spring源码解析</a><time datetime="2021-12-16T04:41:35.000Z" title="发表于 2021-12-16 12:41:35">2021-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/15/%E5%86%8D%E7%9C%8BDubbo-%E7%BA%AF%E6%89%8B%E5%86%99Dubbo%E3%80%81%E7%90%86%E8%A7%A3Dubbo%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" title="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112151623189.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构"/></a><div class="content"><a class="title" href="/2021/12/15/%E5%86%8D%E7%9C%8BDubbo-%E7%BA%AF%E6%89%8B%E5%86%99Dubbo%E3%80%81%E7%90%86%E8%A7%A3Dubbo%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" title="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构">再看Dubbo-纯手写Dubbo、理解Dubbo整体架构</a><time datetime="2021-12-15T08:15:13.000Z" title="发表于 2021-12-15 16:15:13">2021-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/11/%E6%88%91%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BD%AE%E5%AD%90%EF%BC%8Cclever-spring%EF%BC%8C%E5%B8%AE%E5%8A%A9%E6%82%A8%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3Spring%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" title="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程"/></a><div class="content"><a class="title" href="/2021/12/11/%E6%88%91%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BD%AE%E5%AD%90%EF%BC%8Cclever-spring%EF%BC%8C%E5%B8%AE%E5%8A%A9%E6%82%A8%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3Spring%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" title="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程">我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程</a><time datetime="2021-12-10T18:00:02.000Z" title="发表于 2021-12-11 02:00:02">2021-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/" title="HDFS的读写数据流程详解与节点距离的计算分析"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191150455.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HDFS的读写数据流程详解与节点距离的计算分析"/></a><div class="content"><a class="title" href="/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/" title="HDFS的读写数据流程详解与节点距离的计算分析">HDFS的读写数据流程详解与节点距离的计算分析</a><time datetime="2021-09-19T04:19:47.000Z" title="发表于 2021-09-19 12:19:47">2021-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/12/MySQL%EF%BC%88InnoDB%EF%BC%89-%E8%A7%A3%E9%94%81%E4%BC%98%E5%8C%96-semi-consitent-read-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" title="MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210712113024.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析"/></a><div class="content"><a class="title" href="/2021/07/12/MySQL%EF%BC%88InnoDB%EF%BC%89-%E8%A7%A3%E9%94%81%E4%BC%98%E5%8C%96-semi-consitent-read-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" title="MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析">MySQL（InnoDB） 解锁优化 semi-consitent read 原理及实现分析</a><time datetime="2021-07-12T03:27:05.000Z" title="发表于 2021-07-12 11:27:05">2021-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191150455.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 努力努力再努力xLg</div><div class="footer_custom_text">Hi, welcome to my <a href="https://assumejson.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '9AMDI214RvL33G4AGFf7UWeM-gzGzoHsz',
      appKey: 'alFvEcPpeVWr0nyL36RrYHbY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="6852130449" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-DDLT48PGF4', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>