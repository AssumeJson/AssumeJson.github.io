<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Netty 源码分析 —— NIO 基础（四）之 Selector | 努力努力再努力xLg</title><meta name="keywords" content="Netty,网络通讯,NIO"><meta name="author" content="努力努力再努力xLg,954253184@qq.com"><meta name="copyright" content="努力努力再努力xLg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Thinking   一个技术，为什么要用它，解决了那些问题？ 如果不用会怎么样，有没有其它的解决方法？ 对比其它的解决方案，为什么最终选择了这种，都有何利弊？ 你觉得项目中还有那些地方可以用到，如果用了会带来那些问题？ 这些问题你又如何去解决的呢？   本文基于Netty 4.1.45.Final-SNAPSHOT 1、概述前言 ​    在JDK1.4中引入的new i&#x2F;o其中最最重要关键就是">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 源码分析 —— NIO 基础（四）之 Selector">
<meta property="og:url" content="https://assumejson.github.io/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B-Selector/index.html">
<meta property="og:site_name" content="努力努力再努力xLg">
<meta property="og:description" content="Thinking   一个技术，为什么要用它，解决了那些问题？ 如果不用会怎么样，有没有其它的解决方法？ 对比其它的解决方案，为什么最终选择了这种，都有何利弊？ 你觉得项目中还有那些地方可以用到，如果用了会带来那些问题？ 这些问题你又如何去解决的呢？   本文基于Netty 4.1.45.Final-SNAPSHOT 1、概述前言 ​    在JDK1.4中引入的new i&#x2F;o其中最最重要关键就是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png">
<meta property="article:published_time" content="2021-07-11T09:19:42.000Z">
<meta property="article:modified_time" content="2021-07-11T09:24:57.688Z">
<meta property="article:author" content="努力努力再努力xLg">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="网络通讯">
<meta property="article:tag" content="NIO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://assumejson.github.io/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B-Selector/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1db2391382f6b742f88f4d4bacf084e1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-DDLT48PGF4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DDLT48PGF4');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"9U77PNXQGB","apiKey":"c7a45d15e80ae02575c385328d379977","indexName":"dev_blog_search","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 努力努力再努力xLg","link":"链接: ","source":"来源: 努力努力再努力xLg","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Netty 源码分析 —— NIO 基础（四）之 Selector',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-11 17:24:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710212139.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">努力努力再努力xLg</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Netty 源码分析 —— NIO 基础（四）之 Selector</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-11T09:19:42.000Z" title="发表于 2021-07-11 17:19:42">2021-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-11T09:24:57.688Z" title="更新于 2021-07-11 17:24:57">2021-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/">Develop</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/Netty/">Netty</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/Netty/NIO/">NIO</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Netty 源码分析 —— NIO 基础（四）之 Selector"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>Thinking</strong></p>
<blockquote>
<ol>
<li>一个技术，为什么要用它，解决了那些问题？</li>
<li>如果不用会怎么样，有没有其它的解决方法？</li>
<li>对比其它的解决方案，为什么最终选择了这种，都有何利弊？</li>
<li>你觉得项目中还有那些地方可以用到，如果用了会带来那些问题？</li>
<li>这些问题你又如何去解决的呢？</li>
</ol>
</blockquote>
<p><strong>本文基于Netty 4.1.45.Final-SNAPSHOT</strong></p>
<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p><strong>前言</strong></p>
<p>​    在JDK1.4中引入的<code>new i/o</code>其中最最重要关键就是<code>Selector</code>选择器。它在Java NIO 中用于<strong>轮询</strong>能够检测一到多个NIO通道（NIO Channel），并能够知晓通道是否伪诸如读写事件做好准备的组件（可读可写的状态）。这样，一个单独的线程就可以实现管理多个Channel，从而管理多个网络连接。也因此，Selector也被称为<strong>多路复用器</strong>。</p>
<p>​    <strong>与传统I/O对比，Selector优势在哪里。解决了那些痛点。</strong>（其实很多技术大多数都是在追求优化性能的情况下，尽可能地提高程序运行速度。毕竟现在是个连吃快餐都觉得麻烦的时代）</p>
<ol>
<li>使用单独的线程完成对多通道读写的监控，避免了BIO中1连接1请求的阻塞。</li>
<li>使用单独线程大大的减少了，线程上下文切换的资源消耗。</li>
<li>使用单独线程大大减轻了传统IO中大量线程的资源消耗。（较于现在CPU多核越来越优秀的情况下，多线程的开销会越来越小。所以这种情况都是视情况而定的。）</li>
</ol>
<p><strong>Selector是如何实现轮询的呢？</strong></p>
<ul>
<li>首先，需要将Channel注册到Selector中，这样Selector才能知道到底有那些Channel属于它管理的。</li>
<li>然后，Selector会不断的轮询注册在其上的Channel。如果某个Channel上面发生了读或者写事件，这个Channel就处于就绪状态。会被Selector轮询出来，然后通过SelectorKey获取到所有就绪的Channel集合，进行后面的I/O操作。</li>
<li>如下图所示</li>
</ul>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711171829.png" alt="Selector轮询"></p>
<h1 id="2、优缺点对比"><a href="#2、优缺点对比" class="headerlink" title="2、优缺点对比"></a>2、优缺点对比</h1><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>​    使用一个线程能够处理多个Channel，只需要更少的线程来处理Channel。事实上，可以使用一个线程处理所有的Channel。对于操作系统来说，线程之间的上下文切换的开销是非常大的，而且每个线程都是需要占用系统资源的（如：CPU、内存）。</p>
<p>​    简单来说，就是使用更少的线程，优化性能，并且避免了不必要的性能开销。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>​    因为在一个线程中使用多个Channel，因此会造成每个Channel处理效率降低。</p>
<p>（在Netty的设计中，通过Reactor模型对此种情况进行了优化，在我们第一张探讨I/O模型时，提到过，使用多线程管理Channel，将主Reactor分为多个，用于分别处理请求，和接受请求。一般情况下伪CPU*2）</p>
<h1 id="3、Selector"><a href="#3、Selector" class="headerlink" title="3、Selector"></a>3、Selector</h1><p>​    <code>java.nio.channels.Selector</code>抽象类。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711171832.png" alt="类图"></p>
<p>这里多提一嘴，因为Selector 的实现是根据操作系统来具体实现的，所以这里是WindowsSelectorImpl，如果在Lunix/mac下看到的不一样，也不用惊慌。</p>
<p>对Selector源码感兴趣推荐<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0d497fe5484a">《深入浅出NIO之Selector实现原理》</a> 。</p>
<h1 id="4、创建Selector"><a href="#4、创建Selector" class="headerlink" title="4、创建Selector"></a>4、创建Selector</h1><p>​    通过<code>#open()</code>方法，我们可以创建一个Selector对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<h1 id="5、注册Channel到Selector中"><a href="#5、注册Channel到Selector中" class="headerlink" title="5、注册Channel到Selector中"></a>5、注册Channel到Selector中</h1><p>​    每一个需要Selector管理的Channel都需要注册到其上，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文件Channel</span></span><br><span class="line"><span class="comment">// FileChannel channel = new RandomAccessFile(&quot;E:/idea_workspace/springcloud2.0/netty/netty-mytest/src/main/resources/data/Selector-data.txt&quot;, &quot;rw&quot;).getChannel();</span></span><br><span class="line">        <span class="comment">// 文件 是不可以注册到Selector 中的，因为FileChannel 是阻塞的，如果想要注册到Selector 中就必须非阻塞的。</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 开启 异步,只有开启了 异步，让Channel 为非阻塞状态才能注册到Selector中。</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//《1》</span></span><br><span class="line">        <span class="comment">//  让Selector 管理Channel</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">// 《2》</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>注意</strong>，如果一个 Channel 要注册到 Selector 中，那么该 Channel 必须是<strong>非阻塞</strong>，所以 <code>&lt;1&gt;</code> 处的 <code>channel.configureBlocking(false);</code> 代码块。也因此，FileChannel 是不能够注册到 Channel 中的，因为它是<strong>阻塞</strong>的。</p>
<ul>
<li><strong>为什么FileChannel 不能设置为非阻塞的。（见文末详解）</strong></li>
</ul>
</li>
<li><p>在 <code>#register(Selector selector, int interestSet)</code> 方法的<strong>第二个参数</strong>，表示一个“interest 集合”，意思是通过 Selector 监听 Channel 时，对<strong>哪些</strong>( 可以是多个 )事件感兴趣。可以监听四种不同类型的事件：</p>
<ul>
<li><strong>Connect</strong> ：连接完成事件( TCP 连接 )，<strong>仅适用于客户端</strong>，对应 <code>SelectionKey.OP_CONNECT</code> 。</li>
<li><strong>Accept</strong> ：接受新连接事件，<strong>仅适用于服务端</strong>，对应 <code>SelectionKey.OP_ACCEPT</code> 。</li>
<li><strong>Read</strong> ：读事件，适用于两端，对应 <code>SelectionKey.OP_READ</code> ，表示 Buffer 可读。</li>
<li><strong>Write</strong> ：写时间，适用于两端，对应 <code>SelectionKey.OP_WRITE</code> ，表示 Buffer 可写。</li>
</ul>
<p>Channel 触发了一个事件，意思是该事件已经就绪：</p>
</li>
<li><p>一个 Client Channel Channel 成功连接到另一个服务器，称为“连接就绪”。</p>
</li>
<li><p>一个 Server Socket Channel 准备好接收新进入的连接，称为“接收就绪”。</p>
</li>
<li><p>一个有数据可读的 Channel ，可以说是“读就绪”。</p>
</li>
<li><p>一个等待写数据的 Channel ，可以说是“写就绪”。</p>
</li>
</ul>
<hr>
<p>因为 Selector 可以对 Channel 的<strong>多个</strong>事件感兴趣，所以在我们想要注册 Channel 的多个事件到 Selector 中时，可以使用<strong>或运算</strong> <code>|</code> 来组合多个事件。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<hr>
<p>实际使用时，我们会有<strong>改变</strong> Selector 对 Channel 感兴趣的事件集合，可以通过再次调用 <code>#register(Selector selector, int interestSet)</code> 方法来进行变更。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure>

<ul>
<li>初始时，Selector 仅对 Channel 的 <code>SelectionKey.OP_READ</code> 事件感兴趣。</li>
<li>修改后，Selector 仅对 Channel 的 <code>SelectionKey.OP_READ</code> 和 <code>SelectionKey.OP_WRITE)</code> 事件<strong>都</strong>感兴趣。</li>
</ul>
<h1 id="6、-SelectionKey-类"><a href="#6、-SelectionKey-类" class="headerlink" title="6、 SelectionKey 类"></a>6、 SelectionKey 类</h1><p>上一小节, 当我们调用 Channel 的 <code>#register(...)</code> 方法，向 Selector 注册一个 Channel 后，会返回一个 SelectionKey 对象。那么 SelectionKey 是什么呢？SelectionKey 在 <code>java.nio.channels</code> 包下，被定义成一个<strong>抽象类</strong>，表示一个 Channel 和一个 Selector 的注册关系，包含如下内容：</p>
<ul>
<li>interest set ：感兴趣的事件集合。</li>
<li>ready set ：就绪的事件集合。</li>
<li>Channel</li>
<li>Selector</li>
<li>attachment ：<em>可选的</em>附加对象。</li>
</ul>
<h2 id="6-1、-interest-set"><a href="#6-1、-interest-set" class="headerlink" title="6.1、 interest set"></a>6.1、 interest set</h2><p>通过调用 <code>#interestOps()</code> 方法，返回感兴趣的事件集合。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line">// 判断对哪些事件感兴趣</span><br><span class="line">boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT != 0;</span><br><span class="line">boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT != 0;</span><br><span class="line">boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ != 0;</span><br><span class="line">boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE != 0;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中每个事件 Key 在 SelectionKey 中枚举，通过位( bit ) 表示。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  SelectionKey.java</span><br><span class="line"></span><br><span class="line">public static final int OP_READ = 1 &lt;&lt; 0;</span><br><span class="line">public static final int OP_WRITE = 1 &lt;&lt; 2;</span><br><span class="line">public static final int OP_CONNECT = 1 &lt;&lt; 3;</span><br><span class="line">public static final int OP_ACCEPT = 1 &lt;&lt; 4;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以，在上述示例的后半段的代码，可以通过与运算 <code>&amp;</code> 来判断是否对指定事件感兴趣。</li>
</ul>
</li>
</ul>
<h2 id="6-2、-ready-set"><a href="#6-2、-ready-set" class="headerlink" title="6.2、 ready set"></a>6.2、 ready set</h2><p>通过调用 <code>#readyOps()</code> 方法，返回就绪的事件集合。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断哪些事件已就绪</span></span><br><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>相比 interest set 来说，ready set 已经内置了判断事件的方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SelectionKey.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_READ) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isConnectable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_CONNECT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_ACCEPT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-3、-attachment"><a href="#6-3、-attachment" class="headerlink" title="6.3、 attachment"></a>6.3、 attachment</h2><p>通过调用 <code>#attach(Object ob)</code> 方法，可以向 SelectionKey 添加附加对象；通过调用 <code>#attachment()</code> 方法，可以获得 SelectionKey 获得附加对象。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>

<p>又获得在注册时，直接添加附加对象。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>

<h1 id="7、-通过-Selector-选择-Channel"><a href="#7、-通过-Selector-选择-Channel" class="headerlink" title="7、 通过 Selector 选择 Channel"></a>7、 通过 Selector 选择 Channel</h1><p>在 Selector 中，提供三种类型的选择( select )方法，返回当前有感兴趣事件准备就绪的 Channel <strong>数量</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Selector.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞到至少有一个 Channel 在你注册的事件上就绪了。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 `#select()` 方法的基础上，增加超时机制。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 `#select()` 方法不同，立即返回数量，而不阻塞。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>有一点<strong>非常需要注意</strong>：select 方法返回的 <code>int</code> 值，表示有多少 Channel 已经就绪。亦即，<strong>自上次调用 select 方法后有多少 Channel 变成就绪状态</strong>。如果调用 select 方法，因为有一个 Channel 变成就绪状态则返回了 1 ；若再次调用 select 方法，如果另一个 Channel 就绪了，它会再次返回1。如果对第一个就绪的 Channel 没有做任何操作，现在就有两个就绪的 Channel ，<strong>但在每次 select 方法调用之间，只有一个 Channel 就绪了，所以才返回 1</strong>。</li>
</ul>
<h1 id="8、-获取可操作的-Channel"><a href="#8、-获取可操作的-Channel" class="headerlink" title="8、 获取可操作的 Channel"></a>8、 获取可操作的 Channel</h1><p>一旦调用了 select 方法，并且返回值表明有一个或更多个 Channel 就绪了，然后可以通过调用Selector 的 <code>#selectedKeys()</code> 方法，访问“已选择键集( selected key set )”中的<strong>就绪</strong> Channel 。示例代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，当有<strong>新增就绪</strong>的 Channel ，需要先调用 select 方法，才会添加到“已选择键集( selected key set )”中。否则，我们直接调用 <code>#selectedKeys()</code> 方法，是无法获得它们对应的 SelectionKey 们。</li>
</ul>
<h1 id="9、唤醒-Selector-选择"><a href="#9、唤醒-Selector-选择" class="headerlink" title="9、唤醒 Selector 选择"></a>9、唤醒 Selector 选择</h1><p>某个线程调用 <code>#select()</code> 方法后，发生阻塞了，即使没有通道已经就绪，也有办法让其从 <code>#select()</code> 方法返回。</p>
<ul>
<li>只要让其它线程在第一个线程调用 <code>select()</code> 方法的那个 Selector 对象上，调用该 Selector 的 <code>#wakeup()</code> 方法，进行唤醒该 Selector 即可。</li>
<li>那么，阻塞在 <code>#select()</code>方法上的线程，会立马返回。</li>
</ul>
<blockquote>
<p>Selector 的 <code>#select(long timeout)</code> 方法，若未超时的情况下，也可以满足上述方式。</p>
</blockquote>
<p>注意，如果有其它线程调用了 <code>#wakeup()</code> 方法，但当前没有线程阻塞在 <code>#select()</code> 方法上，下个调用 <code>#select()</code> 方法的线程会立即被唤醒。</p>
<h1 id="10、关闭-Selector"><a href="#10、关闭-Selector" class="headerlink" title="10、关闭 Selector"></a>10、关闭 Selector</h1><p>当我们不再使用 Selector 时，可以调用 Selector 的 <code>#close()</code> 方法，将它进行关闭。</p>
<ul>
<li>Selector 相关的所有 SelectionKey 都<strong>会失效</strong>。</li>
<li>Selector 相关的所有 Channel 并<strong>不会关闭</strong>。</li>
</ul>
<p>注意，此时若有线程阻塞在 <code>#select()</code> 方法上，也会被唤醒返回。</p>
<h1 id="11、-简单-Selector-示例"><a href="#11、-简单-Selector-示例" class="headerlink" title="11、 简单 Selector 示例"></a>11、 简单 Selector 示例</h1><p>如下是一个简单的 Selector 示例，创建一个 Selector ，并将一个 Channel注册到这个 Selector上( Channel 的初始化过程略去 )，然后持续轮询这个 Selector 的四种事件( 接受，连接，读，写 )是否就绪。代码如下：</p>
<blockquote>
<p>相较于下面的代码，通常是不可能运用到开发中的，而Netty提供了更加优雅的解决方案。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// 注册 Channel 到 Selector 中</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过 Selector 选择 Channel </span></span><br><span class="line">	<span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">	<span class="keyword">if</span> (readyChannels == <span class="number">0</span>) &#123;</span><br><span class="line">	   <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得可操作的 Channel</span></span><br><span class="line">	Set selectedKeys = selector.selectedKeys();</span><br><span class="line">	<span class="comment">// 遍历 SelectionKey 数组</span></span><br><span class="line">	Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">	<span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">		SelectionKey key = keyIterator.next();</span><br><span class="line">		<span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">			<span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">			<span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">			<span class="comment">// a channel is ready for reading</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">			<span class="comment">// a channel is ready for writing</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 移除</span></span><br><span class="line">		keyIterator.remove(); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意</p>
<p>, 在每次迭代时, 我们都调用（保证事件事件处理完之后，清除掉。不然会 死循环的。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keyIterator.remove()</span><br></pre></td></tr></table></figure>

<p>代码块，将这个 key 从迭代器中删除。</p>
<ul>
<li>因为 <code>#select()</code> 方法仅仅是简单地将就绪的 Channel 对应的 SelectionKey 放到 selected keys 集合中。</li>
<li>因此，如果我们从 selected keys 集合中，获取到一个 key ，但是没有将它删除，那么下一次 <code>#select</code> 时, 这个 SelectionKey 还在 selectedKeys 中.</li>
</ul>
</li>
</ul>
<h1 id="12、问题集合"><a href="#12、问题集合" class="headerlink" title="12、问题集合"></a>12、问题集合</h1><h2 id="12-1、在Channel设置为非阻塞时，为什么FileChannel不能设置为非阻塞的。"><a href="#12-1、在Channel设置为非阻塞时，为什么FileChannel不能设置为非阻塞的。" class="headerlink" title="12.1、在Channel设置为非阻塞时，为什么FileChannel不能设置为非阻塞的。"></a>12.1、在Channel设置为非阻塞时，为什么FileChannel不能设置为非阻塞的。</h2><ul>
<li>源码角度</li>
</ul>
<p>首先我们先看一下FileChannel的源码。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711171842.png" alt="继承子Channel的两个不同分类的Channel"></p>
<p><code>java.nio.channels.FileChannel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">SeekableByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">ScatteringByteChannel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a new instance of this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FileChannel</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>介绍：A channel for reading, writing, mapping, and manipulating a file.</p>
<p>用于读取，写入，映射和操作文件的通道。</p>
<p>并且没有<code>#configureBlocking(boolean block)</code>方法</p>
</blockquote>
<p><code>java.nio.channels.SelectableChannel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Channel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a new instance of this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SelectableChannel</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>介绍：A channel that can be multiplexed via a {@link Selector}.</p>
<p>可以通过{@link Selector}进行多路复用的频道。</p>
<p>并且提供了#configureBlocking(boolean block)`方法</p>
</blockquote>
<p>所以从源码的角度可以看出，所有继承自SelectableChannel抽象类的所有实现都是可以注册到Selector上的。（可以设置为非阻塞Channel），相反则不能。</p>
<ul>
<li><p>从设计角度</p>
<p>在UNIX是不支持文件的非阻塞I/O的，因为将常规文件的描述符设置为非阻塞的是没有任何效果的。（个人理解：因为在常规I/O操作时，读写一定时阻塞的，如果设置为非阻塞，可读可写作为文件的标识符，但是当正在发生读写操作时，还是会阻塞，倘若I/O操作前有一个非常大且缓慢的读写操作，那么该等待的事件还是要等待。因为一个线程不可能同时读写两个文件）详情：</p>
<blockquote>
<p>Every now and then, I hear some programmer complain that a given piece of code uses blocking I/O. The claim is typically that blocking I/O damages the responsiveness of applications, especially if it has a user interface. Hence, solely non-blocking I/O should be used, along with polling (poll() or select()) or an event handling framework (glib, Qt, etc).</p>
<p>I can sympathize with the goal of improving applications responsiveness.<em><strong>*But*</strong></em> that is not an excuse for mixing up <em><strong>*blocking*</strong></em> with <em><strong>*sleeping*</strong></em>. Blocking is just one of several ways to sleep. In other words, non-blocking operations can sleep. Indeed turning non-blocking mode on for a file descriptor will not prevent sleeping in all cases that it could occur, but only one (or two) of them (depending how you count).</p>
<p>Blocking mode refers to one particular and well defined form of sleep: waiting until a file descriptor can be written to or read from. What that really means depends on the type of the underlying file.</p>
<ul>
<li>For sockets, readability means there is some unread data in the input buffers. This is well-known and this is probably the most common use case for non-blocking I/O. Conversely, writeability implies the output buffers are not full as defined by the underlying protocol of the socket. This usually corresponds to congestion control, though the exact mechanisms and policies may vary.</li>
<li>For pipes, readability means some unread data remains in the pipe buffer, or one task is blocking in a write to the other end of the pipe. Reciprocally, writeability means the pipe buffer has available room, or one task is blocking in a read operation on the pipe.</li>
<li>FIFOs are really exactly like pipes, except that they have a name in the file system hierarchy.</li>
<li>Terminals and pseudo-terminals also work much like pipes, with regard to I/O, except for the fact that they support duplex operations like sockets.</li>
<li>For devices (other than terminals), polling is implementation-defined. You need to check the device driver documentation.</li>
<li>For directories, polling is not defined. In any case, writing to directories is not allowed, and reading is only defined through synchronous APIs.</li>
<li>Regular files are <em><strong>*always*</strong></em> readable and they are also <em><strong>*always*</strong></em> writeable. This is clearly stated in the relevant POSIX specifications. <em><strong>*I cannot stress this enough. Putting a regular file in non-blocking has ABSOLUTELY no effects*</strong></em> other than changing one bit in the file flags.</li>
</ul>
<p>Reading from a regular file might take a long time. For instance, if it is located on a busy disk, the I/O scheduler might take so much time that the user will notice the application is <em>frozen</em>.</p>
<p>Nevertheless, non-blocking mode will not work. It simply will not work. Checking a file for readability or writeability always succeeds immediately. If the system needs time to perform the I/O operation, it will put the task in <em>non-interruptible sleep</em> from the read or write system call.</p>
<p>In other words, if you do know that a file descriptor refers to a regular file, do not waste your time, or worse, other people’s time implementing non-blocking I/O.<br>The only safe way to read data from or write data to a regular file while not blocking a task… is to not do it - in that particular task. Concretely, you need to create a separate thread (or process), whether you like it or not, even if you think threads suck (which usually really means you are an incompetent programmer who cannot use threads properly).</p>
<p>An alternative, of course, involves reading small chunks of data at once, and handling other events in-between. Then again, even reading a single byte can take a long time, if said byte was not <em>read ahead</em> by the operating system.</p>
<p>原文链接：<a target="_blank" rel="noopener" href="http://www.remlab.net/op/nonblock.shtml">http://www.remlab.net/op/nonblock.shtml</a></p>
</blockquote>
<p>基于上述描述，就像RPC框架一样，Java也得需要经可能的保证大范围的适配运行环境。所以<code>FileChannel</code>并没有实现或者继承自<code>SelectableChannel</code>。</p>
</li>
</ul>
<p>​    但是JDK 7 之后就支持了异步文件I/O新<code>java.nio.channels.AsynchronousFileChannel</code>类,这是不阻塞I / O的不同机制.其中一个实现<code>sun.nio.ch.WindowsAsynchronousFileChannelImpl</code>受益于Windows上的非阻塞I / O API(参见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liujx2019/p/11692492.html">Asynchronous I/O in Windows</a>.</p>
<p>​    在此期间,您可以使用多个线程来实现相同的效果.但是这已经在<code>jdk.management.resource.internal.inst.SimpleAsynchronousFileChannelImplRMHooks</code>中实现,它可以在所有操作系统中移植（//TODO 有兴趣可以先研究一下。）</p>
<blockquote>
<p>本文仅供笔者本人学习，有错误的地方还望指出，一起进步！望海涵！</p>
<p><strong>转载请注明出处！</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.jb51.cc/java/125209.html">为什么Java中的FileChannel不是非阻塞的？</a></p>
<p>欢迎关注我的公共号，无广告，不打扰。不定时更新Java后端知识，我们一起超神。<br><img src="https://upload-images.jianshu.io/upload_images/13488989-32326cc50c8f4954.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode.jpg"></p>
<p>——努力努力再努力xLg</p>
<p>加油！</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:954253184@qq.com">努力努力再努力xLg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://assumejson.github.io/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B-Selector/">https://assumejson.github.io/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B-Selector/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://assumejson.github.io" target="_blank">努力努力再努力xLg</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Netty/">Netty</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/">网络通讯</a><a class="post-meta__tags" href="/tags/NIO/">NIO</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-60e9a8d4f9258832" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013059.png" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013059.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013135.jpg" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013135.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B-Buffer/"><img class="prev-cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Netty 源码分析 —— NIO 基础（三）之 Buffer</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%85%B6%E5%AE%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><img class="next-cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty 源码分析 —— NIO 基础（五）之零拷贝与其它源码解读</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/11/Netty-源码分析-——-NIO-基础（一）之IO模型超详细讲解/" title="Netty 源码分析 —— NIO 基础（一）之IO模型超详细讲解"><img class="cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-11</div><div class="title">Netty 源码分析 —— NIO 基础（一）之IO模型超详细讲解</div></div></a></div><div><a href="/2021/07/11/Netty-源码分析-——-NIO-基础（二）之-Channel/" title="Netty 源码分析 —— NIO 基础（二）之 Channel"><img class="cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-11</div><div class="title">Netty 源码分析 —— NIO 基础（二）之 Channel</div></div></a></div><div><a href="/2021/07/11/Netty-源码分析-——-NIO-基础（五）之零拷贝与其它源码解读/" title="Netty 源码分析 —— NIO 基础（五）之零拷贝与其它源码解读"><img class="cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-11</div><div class="title">Netty 源码分析 —— NIO 基础（五）之零拷贝与其它源码解读</div></div></a></div><div><a href="/2021/07/11/Netty-源码分析-——-NIO-基础（三）之-Buffer/" title="Netty 源码分析 —— NIO 基础（三）之 Buffer"><img class="cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-11</div><div class="title">Netty 源码分析 —— NIO 基础（三）之 Buffer</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710212139.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">努力努力再努力xLg</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AssumeJson"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AssumeJson" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:954253184@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我准备战斗到最后，并不是因为我勇敢，而是我想见证一切。</br>&nbsp;&nbsp;推荐关注我的公众号，无广不打扰。及时推送，保持与博客同步更新。一起进步，一起超神<img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711095917.jpg" /></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">2.</span> <span class="toc-text">2、优缺点对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.0.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.0.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81Selector"><span class="toc-number">3.</span> <span class="toc-text">3、Selector</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BASelector"><span class="toc-number">4.</span> <span class="toc-text">4、创建Selector</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E6%B3%A8%E5%86%8CChannel%E5%88%B0Selector%E4%B8%AD"><span class="toc-number">5.</span> <span class="toc-text">5、注册Channel到Selector中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81-SelectionKey-%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">6、 SelectionKey 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81-interest-set"><span class="toc-number">6.1.</span> <span class="toc-text">6.1、 interest set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81-ready-set"><span class="toc-number">6.2.</span> <span class="toc-text">6.2、 ready set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81-attachment"><span class="toc-number">6.3.</span> <span class="toc-text">6.3、 attachment</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81-%E9%80%9A%E8%BF%87-Selector-%E9%80%89%E6%8B%A9-Channel"><span class="toc-number">7.</span> <span class="toc-text">7、 通过 Selector 选择 Channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81-%E8%8E%B7%E5%8F%96%E5%8F%AF%E6%93%8D%E4%BD%9C%E7%9A%84-Channel"><span class="toc-number">8.</span> <span class="toc-text">8、 获取可操作的 Channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E5%94%A4%E9%86%92-Selector-%E9%80%89%E6%8B%A9"><span class="toc-number">9.</span> <span class="toc-text">9、唤醒 Selector 选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E5%85%B3%E9%97%AD-Selector"><span class="toc-number">10.</span> <span class="toc-text">10、关闭 Selector</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81-%E7%AE%80%E5%8D%95-Selector-%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.</span> <span class="toc-text">11、 简单 Selector 示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">12、问题集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1%E3%80%81%E5%9C%A8Channel%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88FileChannel%E4%B8%8D%E8%83%BD%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E3%80%82"><span class="toc-number">12.1.</span> <span class="toc-text">12.1、在Channel设置为非阻塞时，为什么FileChannel不能设置为非阻塞的。</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/26/Seata-docker%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/" title="Seata docker部署报错"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112270010529.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Seata docker部署报错"/></a><div class="content"><a class="title" href="/2021/12/26/Seata-docker%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/" title="Seata docker部署报错">Seata docker部署报错</a><time datetime="2021-12-26T15:32:44.000Z" title="发表于 2021-12-26 23:32:44">2021-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring面试题总结-结合Spring源码解析"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring面试题总结-结合Spring源码解析"/></a><div class="content"><a class="title" href="/2021/12/16/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%BB%93%E5%90%88Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring面试题总结-结合Spring源码解析">Spring面试题总结-结合Spring源码解析</a><time datetime="2021-12-16T04:41:35.000Z" title="发表于 2021-12-16 12:41:35">2021-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/15/%E5%86%8D%E7%9C%8BDubbo-%E7%BA%AF%E6%89%8B%E5%86%99Dubbo%E3%80%81%E7%90%86%E8%A7%A3Dubbo%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" title="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112151623189.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构"/></a><div class="content"><a class="title" href="/2021/12/15/%E5%86%8D%E7%9C%8BDubbo-%E7%BA%AF%E6%89%8B%E5%86%99Dubbo%E3%80%81%E7%90%86%E8%A7%A3Dubbo%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" title="再看Dubbo-纯手写Dubbo、理解Dubbo整体架构">再看Dubbo-纯手写Dubbo、理解Dubbo整体架构</a><time datetime="2021-12-15T08:15:13.000Z" title="发表于 2021-12-15 16:15:13">2021-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/11/%E6%88%91%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BD%AE%E5%AD%90%EF%BC%8Cclever-spring%EF%BC%8C%E5%B8%AE%E5%8A%A9%E6%82%A8%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3Spring%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" title="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202112110204659.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程"/></a><div class="content"><a class="title" href="/2021/12/11/%E6%88%91%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BD%AE%E5%AD%90%EF%BC%8Cclever-spring%EF%BC%8C%E5%B8%AE%E5%8A%A9%E6%82%A8%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3Spring%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" title="我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程">我造了一个轮子，clever-spring，帮助您透彻理解Spring核心流程</a><time datetime="2021-12-10T18:00:02.000Z" title="发表于 2021-12-11 02:00:02">2021-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/" title="HDFS的读写数据流程详解与节点距离的计算分析"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/202109191150455.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HDFS的读写数据流程详解与节点距离的计算分析"/></a><div class="content"><a class="title" href="/2021/09/19/HDFS%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/" title="HDFS的读写数据流程详解与节点距离的计算分析">HDFS的读写数据流程详解与节点距离的计算分析</a><time datetime="2021-09-19T04:19:47.000Z" title="发表于 2021-09-19 12:19:47">2021-09-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 努力努力再努力xLg</div><div class="footer_custom_text">Hi, welcome to my <a href="https://assumejson.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '9AMDI214RvL33G4AGFf7UWeM-gzGzoHsz',
      appKey: 'alFvEcPpeVWr0nyL36RrYHbY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="6852130449" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-DDLT48PGF4', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>