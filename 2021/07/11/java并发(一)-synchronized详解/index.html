<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java并发 一 -- synchronized详解 | 努力努力再努力xLg</title><meta name="keywords" content="Java并发,Java并发编程,并发编程"><meta name="author" content="努力努力再努力xLg,954253184@qq.com"><meta name="copyright" content="努力努力再努力xLg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LET&#96;S GO简介： ​    可能在很多人眼里，在java中提到锁、安全性、同步，首先想到的则是java提供的大佬（synchronized）。那么为什么在多线程下，单单靠一个关键字修饰代码块就可以实现所谓的安全性呢？可以说是对初学者而言及神奇又强大的存在。也成了大多数初学者百试不爽的良药。 ​    但是在逐渐对java认知的深入，我们认识到synchronized对于jvm来说是一个重量级">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发 一 -- synchronized详解">
<meta property="og:url" content="https://assumejson.github.io/2021/07/11/java%E5%B9%B6%E5%8F%91(%E4%B8%80)-synchronized%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="努力努力再努力xLg">
<meta property="og:description" content="LET&#96;S GO简介： ​    可能在很多人眼里，在java中提到锁、安全性、同步，首先想到的则是java提供的大佬（synchronized）。那么为什么在多线程下，单单靠一个关键字修饰代码块就可以实现所谓的安全性呢？可以说是对初学者而言及神奇又强大的存在。也成了大多数初学者百试不爽的良药。 ​    但是在逐渐对java认知的深入，我们认识到synchronized对于jvm来说是一个重量级">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114213.jpg">
<meta property="article:published_time" content="2021-07-11T03:43:28.000Z">
<meta property="article:modified_time" content="2021-07-11T03:50:59.428Z">
<meta property="article:author" content="努力努力再努力xLg">
<meta property="article:tag" content="Java并发">
<meta property="article:tag" content="Java并发编程">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114213.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://assumejson.github.io/2021/07/11/java%E5%B9%B6%E5%8F%91(%E4%B8%80)-synchronized%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1db2391382f6b742f88f4d4bacf084e1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-DDLT48PGF4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DDLT48PGF4');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"9U77PNXQGB","apiKey":"c7a45d15e80ae02575c385328d379977","indexName":"dev_blog_search","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 努力努力再努力xLg","link":"链接: ","source":"来源: 努力努力再努力xLg","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java并发 一 -- synchronized详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-11 11:50:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710212139.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114213.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">努力努力再努力xLg</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java并发 一 -- synchronized详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-11T03:43:28.000Z" title="发表于 2021-07-11 11:43:28">2021-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-11T03:50:59.428Z" title="更新于 2021-07-11 11:50:59">2021-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/">Develop</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Develop/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java并发 一 -- synchronized详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="LET-S-GO"><a href="#LET-S-GO" class="headerlink" title="LET`S GO"></a>LET`S GO</h1><p><strong>简介：</strong></p>
<p>​    可能在很多人眼里，在java中提到锁、安全性、同步，首先想到的则是java提供的大佬（<code>synchronized</code>）。那么为什么在多线程下，单单靠一个关键字修饰代码块就可以实现所谓的安全性呢？可以说是对初学者而言及神奇又强大的存在。也成了大多数初学者百试不爽的良药。</p>
<p>​    但是在逐渐对java认知的深入，我们认识到<code>synchronized</code>对于jvm来说是一个重量级的锁。其笨重无比，在如今人们对速度和性能极致要求的现在，现在此时并不能满足性能上的要求。</p>
<p>​    诚然<code>SUN</code>公司也认识到了这一点，在Java SE 1.6对<code>synchronized</code>进行了各种优化后，有些情况下它就并不那么笨重<code>🐖</code>了。在Java SE 1.6中为了减少获得锁和释放锁带来的性能开销而引入偏向锁和轻量级锁。</p>
<blockquote>
<p>2020.3.2 13点26分 更新</p>
</blockquote>
<hr>
<h2 id="Synchronized实现同步的基础"><a href="#Synchronized实现同步的基础" class="headerlink" title="Synchronized实现同步的基础"></a>Synchronized实现同步的基础</h2><p>​    Java中每一个对象都可以作为锁。具体有如下三种形式：</p>
<ul>
<li><p>对于<strong>普通同步方法</strong>，锁是当前实例对象。</p>
</li>
<li><p>对于<strong>静态同步方法</strong>，锁是当前类的<code>Class</code>对象。</p>
</li>
<li><p>对于<strong>同步代码块</strong>，锁是<code>synchronized</code>括号里配置的对象。</p>
</li>
</ul>
<hr>
<h2 id="那么线程是怎么获取上述各种锁对象的呢？"><a href="#那么线程是怎么获取上述各种锁对象的呢？" class="headerlink" title="那么线程是怎么获取上述各种锁对象的呢？"></a>那么线程是怎么获取上述各种锁对象的呢？</h2><p><strong>先看一段简单的三种同步方式</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步修饰普通方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同步修饰代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello synchronized&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步修饰静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用javap 查看生成的class 文件</strong><br><code>javap -verbose ***.class</code></p>
</blockquote>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114441.png" alt="class文件监视器"></p>
<p>JVM会在<code>monitorenter</code>监视器入口处获取锁，然后执行完对应操作后，在<code>monitorexit</code>监视器出口释放锁。在class文件中<code>synchronized</code>被<code>ACC_SYNCHRONIZED</code>标记，表明该方法为同步方法。</p>
<hr>
<p>​    从JVM规范中可以看到<code>Synchronized</code>在JVM里的实现原理，JVM基于进入和推出<code>monitor</code>对象来实现方法同步和代码块同步的，但两者的实现细节不一样。</p>
<ul>
<li>使用synchronized 修饰方法 在字节码文件中会在类头标记中添加<code>ACC_SYNCHRONIZED</code>标记（个人理解为锁的标记不同的原因吧。）<ul>
<li><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114402.png" alt="image-20200302114712520"></li>
</ul>
</li>
</ul>
<p><strong>代码块同步：</strong> 是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的。而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114449.png" alt="image-20200302114853670"></p>
<p><strong>静态同步方法：</strong> 使用javap 可以看出<code>synchronized</code>被编译为普通的命令<code>invokevirtual</code>、<code>areturn</code>字节码指令。在JVM层面并没有任何特别的指令来实现被<code>synchronized</code>修饰的方法，而是在<code>Class</code>文件的方法表中将该方法的<code>access_flags</code>字段中的<code>synchronized</code>标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的<code>Class</code>在JVM的内部对象表示Class作为锁对象。（<a target="_blank" rel="noopener" href="http://www.cnblogs.com/javaminer/p/3889023.html">引用（详细介绍了1.6后锁的各种优化）</a>）</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114455.png" alt="静态同步方法"></p>
<hr>
<h2 id="monitorenter指令"><a href="#monitorenter指令" class="headerlink" title="monitorenter指令"></a>monitorenter指令</h2><p>​    <code>monitorenter</code> 指令时在编译后插入到同步代码块的开始位置的。而<code>monitorexit</code>是插入到方法的结束处和异常处，JVM要保证每个<code>monitorenter</code>必须都有对应的<code>monitorexit</code>与之对应。任何对象都有一个<code>monitor</code>对象与之关联，并且一个<code>monitor</code>被持有后，它将处于锁定状态。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的<code>monitor</code>所有权，即尝试获取对象的锁。</p>
<hr>
<h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>​    <code>synchronized</code>用的锁是存在Java对象头里的。所以这里对Java对象头做详细介绍。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>​    在<code>HotSpot</code>虚拟机中，对象在内存中存储的布局可以分为3块区域：</p>
<ul>
<li><p>对象头（Header）</p>
</li>
<li><p>实例数据（Instance Data）</p>
</li>
<li><p>对齐填充（Padding）</p>
<p>HotSpot虚拟机的对象头包括两部分信息，<strong>第一部分</strong>用于存储对象自身的运行时数据，如哈希码（<code>HashCode</code>）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别位32bit和64bit，官方称它位“<code>Mark Word</code>” （标记字段）。对象需要存储的运行时数据很多，其实已经超出了定义的位数。</p>
<p><code>Mark Word</code>被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位HotSpot虚拟机中，如果对象处于被锁定状态下，那么<code>Mark Word</code>的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定位0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表</p>
<table>
<thead>
<tr>
<th align="center">存储内容</th>
<th align="center">标志位</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">对象哈希码、对象分代年龄</td>
<td align="center">01</td>
<td align="center">未锁定</td>
</tr>
<tr>
<td align="center">指向锁记录的指针</td>
<td align="center">00</td>
<td align="center">轻量级锁定</td>
</tr>
<tr>
<td align="center">指向重量级锁的指针</td>
<td align="center">10</td>
<td align="center">膨胀（重量级锁定）</td>
</tr>
<tr>
<td align="center">空，不需要记录信息</td>
<td align="center">11</td>
<td align="center">GC标记</td>
</tr>
<tr>
<td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td>
<td align="center">01</td>
<td align="center">可偏向</td>
</tr>
</tbody></table>
<p>​    <img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114621.png" alt="锁的类型"></p>
<p>​    对象头的另外一部分是类型指针（<code>Klass Pointer</code>）。即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数据长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的原数组中却无法确定数组的大小。</p>
<p>​    在运行期间，<code>Mark Word</code>标记字段里存储的数据会随着锁的标志位的变化而变化</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114624.png" alt="Mark Word的状态变化"></p>
<p><strong>无锁状态下<code>Mark Word</code>:</strong>  对象的<code>hashCode</code>+对象分代年龄+（是否为偏向锁）0+（所标志位）01</p>
<hr>
<h3 id="Monitor-Record"><a href="#Monitor-Record" class="headerlink" title="Monitor Record"></a>Monitor Record</h3><p><code>Monitor</code> 从字面意义上理解为监控、监视的意思。在Java中可以把它看作为一个同步工具，相当于操作系统中的互斥量，即值为1的信号量。它内置与每一个对象。在java世界里，每一个对象天生都拥有一把内置锁（<code>Monitor</code>）。这相当于一个许可证，只有你拿到许可证之后才可以进行操作，没有拿到则需要进行阻塞等待。</p>
<p><code>Monitor Record</code>从字面意义上理解为：监视器记录。<code>Monitor Record</code>是线程私有的数据结构，每一个线程都有一个可用<code>Monitor Record</code>列表，同时还有一个全局的可用列表。<strong>每一个被锁住的对象都会和一个monitor record关联</strong>（对象头的MarkWord中的LockWord指向monitor record的起始地址），同时monitor record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。如下图所示为Monitor Record的内部结构 </p>
<table>
<thead>
<tr>
<th><strong>Monitor Record</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Owner</td>
<td>初始时为<code>NULL</code>表示当前没有任何线程拥有该<code>Monitor Record</code>当线程成功拥有该锁后，记录该线程ID作为唯一标识，当锁被释放时又设置成<code>NULL</code></td>
</tr>
<tr>
<td>EntryQ</td>
<td>关联一个系统互斥锁（<code>semaphore</code>信号量），阻塞所有试图锁住<code>Monitor Recoed</code>失败的线程</td>
</tr>
<tr>
<td>RcThis</td>
<td>表示<code>blocked</code>或者<code>waiting</code>在该<code>Monitor Record</code>上所有的线程的个数</td>
</tr>
<tr>
<td>Nest</td>
<td>用来实现重入锁的计数</td>
</tr>
<tr>
<td>HashCode</td>
<td>保存从对象头拷贝过来的HashCode值（可能还包含GC分代年龄）</td>
</tr>
<tr>
<td>Candidate</td>
<td>用来避免不必要的阻塞或者等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，那么当执行线程结束任务释放锁后，如果唤醒所有等待的线程，会造成不必要的上下文切换（影响性能，因为在所有唤醒的线程中，只有一个能够真正的获取到锁，所以其他的线程在从阻塞到就绪到因为竞争锁失败又被阻塞，这中间都是一些不必要的资源浪费）。所以Candidate只提供了两种可能，<code>0</code>表示当前没有需要唤醒的线程。<code>1</code>表示在阻塞的线程中，唤醒一个继任线程来竞争锁</td>
</tr>
</tbody></table>
<hr>
</li>
</ul>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>​    高效并发是从JDK 1.5 到 JDK 1.6的一个重要改进，<code>HotSpot</code>虚拟机在这个版本上花费了大量精力去实现各种锁优化技术，如：<strong>适应性自旋（<code>Adaptive Spinning</code>）、锁消除（<code>Lock Eliminate </code>）、锁粗化（<code>Lock Coarsening</code>）、轻量级锁（<code>Lightweight Locking</code>）和偏向锁（<code>Biased Locking</code>）</strong>等，这些技术都是为了在先咸亨之间更搞笑地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>​    在Java SE 1.6里<code>Synchronied</code>同步锁，一共有四种状态：<strong>无锁、偏向锁、轻量级所、重量级锁</strong>，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。</p>
<blockquote>
<p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 （此过程是不可逆的）</p>
</blockquote>
<h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><blockquote>
<p>引入背景</p>
<p>​    大家都知道，在没有加入锁优化时，大佬<code>Synchronized</code>时一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成（涉及到大量的线程上下文切换的消耗），这些操作给系统的并发性能带来了很大的压力。</p>
<p>​    同时<code>HotSpot</code>团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会（自旋），但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一段无意义的循环（自旋），这便是自旋锁由来的原因。</p>
</blockquote>
<p>​    自旋锁早在JDK1.4 中就引入了，只是当时<strong>默认是关闭</strong>的，默认关闭，但是可以使用<code>-XX:+UseSpinning</code>来开启，。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销（因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源）。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，<strong>自旋锁默认的自旋次数为10次，</strong>用户可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p>
<blockquote>
<p>可是现在又出现了一个问题：</p>
<p>​    如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。（这里则需要<strong>自适应自旋锁</strong>！）</p>
</blockquote>
<h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>​    在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准备，JVM也会越来越聪明。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>​    锁消除时指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。</p>
<p>​    当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作<code>String </code>类型数据时，由于<code>String</code>是一个不可变类，对字符串的连接操作总是通过生成的新的<code>String</code>对象来进行的。因此Javac编译器会对<code>String</code>连接做自动优化。在JDK 1.5之前会使用<code>StringBuffer</code>对象的连续<code>appen（）</code>操作，在JDK 1.5及以后的版本中，会转化为<code>StringBuidler</code>对象的连续<code>append（）</code>操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test03</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    String s = s1 + s2 + s3;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vector&lt;String&gt; strings = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        strings.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114640.png" alt="上述代码使用javap 编译结果"></p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114644.png" alt="vetor中的锁消除"></p>
<p>​    众所周知，<code>StringBuffer</code>是安全同步的。但是在上述代码中，JVM判断该段代码并不会逃逸出测试代码外，则将该代码块默认为线程独有的资源，则并不需要同步，所以执行了锁消除操作。（还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内）</p>
<blockquote>
<p>这种大胆的尝试，充分的说明了Java是年轻并且积极向上的，不是吗？永远都在追求新的改变。</p>
</blockquote>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>​    原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围（只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁）。</p>
<p>​    大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。</p>
<p>​    这里贴上根据上述Javap 编译地情况编写地实例java类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test04</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114649.png" alt="image-20200302131327867"></p>
<p>​    在上述地连续<code>append（）</code>操作中就属于这类情况。JVM会检测到这样一连串地操作都是对同一个对象加锁，那么JVM会将加锁同步地范围扩展（粗化）到整个一系列操作的 外部，使整个一连串地<code>append（）</code>操作只需要加锁一次就可以了。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>​    在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来地线程开销。从而提高并发性能。</p>
<p>​    如果要理解轻量级锁，那么必须先要了解<code>HotSpot</code>虚拟机中对象头地内存布局。上面介绍Java对象头也详细介绍过。在对象头中（<code>Object Header</code>）存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、锁标记位、是否为偏向锁。等。一般为32位或者64位（视操作系统位数定）。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针（<code>Klass Point</code>），如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p>
<h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><p>​    在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝（JVM会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>）这个时候线程堆栈与对象头的状态如图：</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114654.png" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p>
<p>​    如上图所示：如果当前对象没有被锁定，那么锁标志位位<code>01</code>状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录<code>Lock Record</code>的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝。</p>
<p>​    然后，虚拟机使用CAS操作将标记字段<code>Mark Word</code>拷贝到锁记录中，并且将<code>Mark Word</code>更新位指向<code>Lock Record</code>的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象<code>Mark Word</code>的锁标志位更新位（<code>Mark Word中最后的2bit</code>）<code>00</code>，即表示此对象处于轻量级锁定状态，如图：</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114657.png" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p>
<p><img src="assets/1533743045867.png" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p>
<p>​    如果这个更新操作失败，JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为<code>10</code>.<code>Mark Word</code>中存储的时指向重量级锁的指针。</p>
<p>​    轻量级解锁时，会使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114701.png" alt="轻量级锁及膨胀流程图"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>​    引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p>
<p>​    为了解决这一问题，<code>HotSpot</code>的作者在Java SE 1.6 中对<code>Synchronized</code>进行了优化，引入了偏向锁。当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和推出同步块时不需要进行<code>CAS</code>操作来加锁和解锁。只需要简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114706.png" alt="偏向锁、轻量级锁的状态转换"></p>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>​    偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点（就是当前线程没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p>
<p><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114731.png" alt="偏向锁的获得和撤销流程"></p>
<h2 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h2><p>​    </p>
<table>
<thead>
<tr>
<th align="center">锁</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td align="center">加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td align="center">适用于只有一个线程访问同步快的场景</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">竞争的线程不会阻塞，提高了响应速度</td>
<td align="center">如线程始终得不到锁竞争的线程，使用自旋会消耗CPU性能</td>
<td align="center">追求响应时间，同步快执行速度非常快</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">线程竞争不适用自旋，不会消耗CPU</td>
<td align="center">线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>
<td align="center">追求吞吐量，同步快执行速度较长</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料</p>
<p>​    《深入理解Java虚拟机》</p>
<p>​    《Java并发编程的艺术》</p>
</blockquote>
<p><strong>本文仅供本人学习之用！！！有欠缺的地方还望指正！！！祝各位工作顺利 😊</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:954253184@qq.com">努力努力再努力xLg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://assumejson.github.io/2021/07/11/java%E5%B9%B6%E5%8F%91(%E4%B8%80)-synchronized%E8%AF%A6%E8%A7%A3/">https://assumejson.github.io/2021/07/11/java%E5%B9%B6%E5%8F%91(%E4%B8%80)-synchronized%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://assumejson.github.io" target="_blank">努力努力再努力xLg</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91/">Java并发</a><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-60e9a8d4f9258832" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013059.png" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013059.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013135.jpg" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711013135.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/11/JVM-%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"><img class="prev-cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711113153.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM-从字节码角度深入探讨JDK动态代理</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BIO%E6%A8%A1%E5%9E%8B%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"><img class="next-cover" src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty 源码分析 —— NIO 基础（一）之IO模型超详细讲解</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710212139.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">努力努力再努力xLg</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AssumeJson"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AssumeJson" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:954253184@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我准备战斗到最后，并不是因为我勇敢，而是我想见证一切。</br>&nbsp;&nbsp;欢迎关注我的公众号，无广不打扰。一起进步，一起超神<img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711095917.jpg" /></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LET-S-GO"><span class="toc-number">1.</span> <span class="toc-text">LET&#96;S GO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">Synchronized实现同步的基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%B8%8A%E8%BF%B0%E5%90%84%E7%A7%8D%E9%94%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">那么线程是怎么获取上述各种锁对象的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monitorenter%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">monitorenter指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">1.4.</span> <span class="toc-text">Java对象头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor-Record"><span class="toc-number">1.4.2.</span> <span class="toc-text">Monitor Record</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">锁的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">自旋锁与自适应自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">自适应自旋锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">1.5.3.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">1.5.4.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.5.5.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">轻量级锁加锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.5.6.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">偏向锁的撤销</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.</span> <span class="toc-text">锁的优缺点对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BIO%E6%A8%A1%E5%9E%8B%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/" title="Netty 源码分析 —— NIO 基础（一）之IO模型超详细讲解"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711122918.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty 源码分析 —— NIO 基础（一）之IO模型超详细讲解"/></a><div class="content"><a class="title" href="/2021/07/11/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-NIO-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BIO%E6%A8%A1%E5%9E%8B%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/" title="Netty 源码分析 —— NIO 基础（一）之IO模型超详细讲解">Netty 源码分析 —— NIO 基础（一）之IO模型超详细讲解</a><time datetime="2021-07-11T04:26:27.000Z" title="发表于 2021-07-11 12:26:27">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/java%E5%B9%B6%E5%8F%91(%E4%B8%80)-synchronized%E8%AF%A6%E8%A7%A3/" title="java并发 一 -- synchronized详解"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114213.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java并发 一 -- synchronized详解"/></a><div class="content"><a class="title" href="/2021/07/11/java%E5%B9%B6%E5%8F%91(%E4%B8%80)-synchronized%E8%AF%A6%E8%A7%A3/" title="java并发 一 -- synchronized详解">java并发 一 -- synchronized详解</a><time datetime="2021-07-11T03:43:28.000Z" title="发表于 2021-07-11 11:43:28">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/JVM-%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" title="JVM-从字节码角度深入探讨JDK动态代理"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711113153.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM-从字节码角度深入探讨JDK动态代理"/></a><div class="content"><a class="title" href="/2021/07/11/JVM-%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" title="JVM-从字节码角度深入探讨JDK动态代理">JVM-从字节码角度深入探讨JDK动态代理</a><time datetime="2021-07-11T03:27:09.000Z" title="发表于 2021-07-11 11:27:09">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/" title="MySQL中的锁"><img src="https://gitee.com/ligangyun/cloudimg/raw/master/img/20210710154522.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL中的锁"/></a><div class="content"><a class="title" href="/2021/07/11/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/" title="MySQL中的锁">MySQL中的锁</a><time datetime="2021-07-10T17:10:08.000Z" title="发表于 2021-07-11 01:10:08">2021-07-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/ligangyun/cloudimg/raw/master/img/20210711114213.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 努力努力再努力xLg</div><div class="footer_custom_text">Hi, welcome to my <a href="https://assumejson.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '9AMDI214RvL33G4AGFf7UWeM-gzGzoHsz',
      appKey: 'alFvEcPpeVWr0nyL36RrYHbY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="6852130449" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-DDLT48PGF4', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>